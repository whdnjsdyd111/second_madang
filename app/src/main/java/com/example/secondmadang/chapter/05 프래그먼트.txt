            05-1 프래그먼트란?

여러 화면 구성할 때 보통 각각의 화면을 액티비티로 만들어 전환하는 방법을 사용한다.
근데 일부분만 다른 화면으로 전환하는 방법도 필요할 수 있다.


        프래그먼트에 대한 이해

한 화면을 구성하는 XML 레이아웃 만들 때 리니어 레이아웃 안에 다른 리니어를 넣을 수 있다.
즉, 부분 화면은 전체 화면에서 레이아웃 안의 레이아웃으로 만들 수 있다.

이렇게 만들면 각각에 뷰를 넣어 화면을 만들 수 있지만 코드가 복잡해진다.
여러 레이아웃을 중첩하여 만든다면 동시에 보이는 상태인지, 메모리에 만들어졌는지 등 관리하기 힘들다.

다른 방법으로는 한 액티비티 안에 여러 액티비티를 부분 화면으로 올려서 보여주는 방법이 있다.
구체적으로 Activity 클래스와 ActivityGroup 클래스를 사용하여 구현할 수 있다.
하지만 액티비티는 한 화면을 독립적으로 구성할 때 필요한 여러 속성들을 사용하게되고,
안드로이드 시스템에서 관리하는 앱 구성 요소이기 때문에 액티비티 안에 다른 액티비티를 넣는 것은
단말의 리소스를 많이 사용하는 비효율적이다.

다른 예로는 전화번호 리스트와 전화번호 정보가 있다면 두 액티비티가 서로 전환되는데,
이와 다르게 한 액티비티 안에 두 화면을 같이 넣는 것이다.
한 화면을 여러 부분으로 나눠서 보여주거나 각각의 부분 화면 단위로 바꿔서 보여주고 싶을 때
이 프래그먼트를 사용한다. 한 화면에 부분 화면같이 하나의 레이아웃처럼 보인다.
하지만 액티비티처럼 독립적으로 동작하는 부분화면을 만들때 사용한다.

프래그먼트가 만들어진 목적은 분할된 화면들을 독립적으로 구성하고 상태를 같이 관리하기 위해 사용한다.

또 한가지는 프래그먼트는 항상 액티비티 위에 올라가 있어야하는 점이다.
화면을 분할한 뒤 각각의 부분 화면을 프래그먼트로 만들고 독립적으로 관리해야하기 때문에 액티비티 위에
올라가 있어야한다. 따라서 프래그먼트의 동작 시점은 메모리에 만들어진 시점이 아닌 액티비티가 올라가는 시점이다.
프래그먼트는 다음과 같은 형태로 동작한다.


    액티비티 #1     액티비티 #2

    인텐트     ↔   인텐트
        액티비티 매니저


    프래그먼트 #1    프래그먼트 #2

    메소드 호출 →
            프개르먼트매니저


첫 번째는 액티비티 구성으로 시스템이 관리한다. 액티비티 매니저가 액티비티 동작 순서나 처리 방식을 결정한다.
또 시스템이 관리해서 명ㄹ령이나 데이터는 인텐트를 통해 전달된다.

두 번째는 프래그먼트가 동작하는 방식이 첫 번째와 유사한데, 동작 방식은 본떠 만들었지만
액티비티 매니저가 아닌 프래그먼트 매니저라는 것을 봐야한다.
인텐트가 시스템을 이해하는 객체인데 이것으로 프래그먼트와 액티비티 사이에 전달하는 것은 바람직하지 않으며
이 때문에 둘 간의 데이터 전달은 단순 메소드를 만들어 호출하는 방식이다.

하지만 프래그먼트에 항상 두 액티비티 이상이 있어야 하는 건 아니며 한 프래그먼트만 액티비티에 올려도 무관하다.
이렇게 한 프래그먼트만 전체를 채워도 전체 화면처럼 느껴져 원하는 시점에 한 프래그먼트를 놨다가
다른 프래그먼트로 바꿔서 보여줄 수 있어 액티비티 전환 없이 전환 효과를 낼 수 있다.

액티비티는 시스템이 관리하지만 프래그먼트는 액티비티 위에 올라가 있어 액티비티를 전환하지 않고 가볍게 화면
전환 효과를 만들 수 있다. 특히 탭 모양으로 화면 구성 시 각각의 [탭] 버튼을 클릭할 때마다 다른 화면이
보이는 효과를 내고 싶다면 액티비티가 아닌 프래그먼트를 사용하는 것이 좋다.


        프래그먼틈를 화면에 추가하는 방법

프래그먼트 만드는 과정은 액티비티와 비슷하다. 액티비티는 한 XML 레이아웃과 자바 코드로 동작하는 것처럼
프래그먼트도 한 XML 레이아웃과 한 자바 코드로 동작한다.

실습을 위해서 fragment_main.xml 파일을 만들어 프래그먼트도 부분 화면이니 XML 레이아웃을 만든다.
그리고 프래그먼트를 위한 자바 소스를 만든다.
프래그먼트를 위한 자바 소스는 Fragment 클래스를 상속하여 만들 수 있다.
다음은 프래그먼트 주요 메소드들이다.


    public final Activity getActivity()
        -> 이 프래그먼트를 포함하는 액티비티를 반환

    public final FragmentManager getFragmentManager()
        -> 이 프래그먼트를 포함하는 액티비티에서 프래그먼트 객체들과 의사소통하는 프래그먼트 매니저를 반환

    public final Fragment getParentFragment()
        -> 프래그먼트를 포함하는 부모가 프래그먼트일 경우 리턴함. 액티비티이면 null 반환

    public final int getId()
        -> 이 프래그먼트의 ID 반환


프래그먼트 클래스 만든 후 소스파일과 매칭하는 과정이 필요하다.
근데 setContentView() 가 없고 대신 인플레이션 객체인 LayoutInflater 를 사용하여 인플레이션을 진행해야 한다.
XML 레이아웃 파일의 내용을 인플레이션한 후 onCreateView() 로 전달해야 한다.
이 메소드는 콜백 메소드라서 자동 호출되니 이 메소드의 인플레이션을 위한 inflate() 메소드를 호출하면
인플레이션 과정이 끝나고 프래그먼트가 하나의 뷰처럼 동작할 수 있는 상태가 된다.

프래그먼트는 버튼이나 레이아웃처럼 화면의 일정 공간을 할당받을 수 있어 새로 만든 프래그먼트를
메인 액티비티에 추가하는 방법은 뷰와 마찬가지로 new 연산자로 객체를 만든 후 프래그먼트 매니저로 추가할 수 있다.
구체적으로 activity_main.xml 파일에 직접 <fragment> 태그로 추가할 수도 있고,
인스턴스 객체를 만들어 FragmentManager 객체의 add() 메소드로도 추가할 수 있다.

메인 액티비티의 레이아웃 파일인 activity_main.xml 파일에 프래그먼트를 추가하면 프래그먼트 화면이 액티비티에 추가된다.
코드에서 프래그먼트를 추가하고 싶다면 프래그먼트 매니저를 사용해야 한다.
프래그먼트 매니저의 주요 메소드는 다음과 같다.


    public abstract FragmentTransaction beginTransaction()
        -> 프래그먼트를 변경하기 위한 트랜잭션을 시작

    public abstract Fragment findFragmentById(int id)
        -> ID 로 프래그먼트 객체를 찾음

    public abstract Fragment findFragmentByTag(String tag)
        -> 태그 정보를 사용해 프래그먼트 객체를 찾음

    public abstract boolean executePendingTransactions()
        -> 트랜잭션은 commit() 메소드를 호출하면 실행되지만 비동기 방식이라 실행 즉시 실행하고 싶다면
            이 메소드를 추가 호출해야 함


FragmentManager 객체는 프래그먼트를 액티비티에 추가, 교환, 삭제를 주로 할 수 있으며 getFragmentManager() 호출하면
참조할 수 있다.


    조언

    프래그먼트 매니저 참조 시 getSupportFragmentManager() 도 호출할 수 있는데
    이 메소드는 이전 버전의 단말에서도 동작할 수 있는 기능이 있어서 예전 버전까지 호환되도록 하려면 이 메소드를 권장한다.


프래그먼트는 다음과 같은 특성을 가지고 있다. 큰 화면에서 더 유용하게 사용될 수 있다.


    특성              설명

    뷰 특성            뷰 그룹에 추가하거나 레이아웃 일부가 될 수 있음(뷰에서 상속이 아닌 일종의 틀)

    액티비티 특성      액티비티처럼 생명주기를 가지고 있음


프래그먼트 클래스는 보통 Fragment 를 상속하지만 미리 정의된 몇 가지 프래그먼트 클래스를 그대로 사용할 때도 있다.
그 중 DialogFragment 는 액티비티의 수명주기에 의해 관리되는 대화상자를 보여줄 수 있도록 한다.
이 프래그먼트는 액티비티 기본 대화상자 대신 사용할 수 있다.


        프래그먼트 만들어 화면에 추가

실습을 위해 fragment_main.xml 파일과 MainFragment.java 를 만든다.
위 레이아웃에 '메인 프래그먼트' 텍스트뷰와 '메뉴 화면으로' 버튼을 만든다.

프래그먼트를 구성할 XML 레이아웃을 만든 후 자바 코드를 수정한다.


    public class MainFragment extends Fragment {
        @Nullable
        @Override
        public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
            return inflater.inflate(R.layout.fragment_main, container, false);
        }
    }


onCreateView() 메소드의 LayoutInflater 객체가 전달되어 이 객체의 inflate() 메소드를 바로 호출할 수 있다.
inflate() 첫 파라미터는 XML 레이아웃으로, 두 번째 파라미터는 설정될 뷰 객체가 되는데
onCreateView() 로 전달되는 두 번째 파라미터가 이 프래그먼트의 가장 상위 레이아웃이다.
그래서 container 객체를 전달하면 된다.

이제 새 프래그먼트를 만들었으니 메인 액티비티에 추가하자.
방법은 XML 태그에 추가하거나 자바 코드로 추가하는 방법이다. 먼저 태그로 추가해보자.


    <?xml version="1.0" encoding="utf-8"?>
    <RelativeLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <fragment
            android:id="@+id/mainFragment"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:name="com.example.secondmadang.MainFragment" />
    </RelativeLayout>


RelativeLayout 의 id 속성을 conatiner1 로 하였으며 <fragment> 태그를 추가했다.
프래그먼트는 뷰와 달라 뷰를 담는 공간만 확보한다. 그래서 태그 이름으로 프래그먼트 이름을 사용할 수 없어,
name 속성에 MainFragment 의 이름을 설정한다.


        버튼 클릭 시 코드에서 프래그먼트 추가

액티비티 화면 위에 올리는 과정을 봤는데, 간단한 과정은 다음과 같다.


    1. 프래그먼트를 위한 XML 레이아웃 생성
    2. 프래그먼트 클래스 생성
    3. 액티비티 XML 레이아웃에 추가


이번엔 MenuFragment 라는 프래그먼트를 하나 더 만들어 MainFragment 안의 버튼 클릭 시 화면이 바뀌게 해보자.
fragment_menu.xml 파일을 만들어 '메뉴 프래그먼트' 텍스트뷰와 '메인 화면으로' 버튼을 생성한다.
MainFragment.java 를 복사하여 MenuFragment.java 로 다음과 같이 변경한다.


    public class MenuFragment extends Fragment {
        @Nullable
        @Override
        public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container1, @Nullable Bundle savedInstanceState) {
            return inflater.inflate(R.layout.fragment_menu, container1, false);
        }
    }


inflate() 메소드로 fragment_menu 를 전달했고 이후 인플레이션되어 설정된다.
이제 클릭했을 때의 처리를 MainFragment.java 에서 코드를 수정한다.


    public class MainFragment extends Fragment {
        @Nullable
        @Override
        public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container1, @Nullable Bundle savedInstanceState) {
            ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_main, container1, false);

            Button button = rootView.findViewById(R.id.button68);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    MainFragment activity = (MainFragment) getActivity();
                    activity.onFragmentChanged(0);
                }
            });

            return rootView;
        }
    }


메인 프래그먼트의 최상위 레이아웃은 인플레이션을 통해 참조한 rootView 객체다.
쉽게 말하면 rootView 는 메인 프래그먼트 안의 화면을 보여주는 틀로서 이를 이용해 findViewById() 메소드로
버튼을 찾을 수 있었다. 그리고 버튼의 리스너에 onFragmentChanged() 메소드를 호출하돍 했는데,
이 메소드는 메인 액티비티에 새로 추가할 메소드로 프래그먼트 매니저를 이용해 프래그먼트를 전환하는 메소드다.
이렇게 하는 이유는 프래그먼트가 다른 프래그먼트를 띄우는 것이 아닌 액티비티를 통해 띄워져야하기 때문이다.

프래그먼트에선 getActivity() 메소드를 호출하면 프래그먼트가 올라간 액티비티가 어떤 것인지 확인할 수 있어
액티비티의 onFragmentChanged() 메소드를 포함한 나머지 필요한 코드를 MainActivity4.java 파일에 추가한다.


    public class MainActivity4 extends AppCompatActivity {
        MainFragment mainFragment;
        MenuFragment menuFragment;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main3);

            mainFragment = (MainFragment) getSupportFragmentManager().findFragmentById(R.id.mainFragment);
            menuFragment = new MenuFragment();
        }

        public void onFragmentChanged(int index) {
            if(index == 0) {
                getSupportFragmentManager().beginTransaction().replace(R.id.container1, menuFragment).commit();
            } else if(index == 1) {
                getSupportFragmentManager().beginTransaction().replace(R.id.container1, mainFragment).commit();
            }
        }
    }


프래그먼트는 뷰가 아니기 때문에 FragmentManager 객체로 findFragmentById() 메소드로 찾을 수 있다.
이후 new 연산자로 새로운 객체를 할당한다.

onFragmentChanged() 메소드는 프래그먼트에서 호출할 수 있도록 정의한 것으로 파라미터로 전달된 정수 값이
0 이면 메인 프래그먼트가 보이게 하고, 1 이면 메뉴 프래그먼트가 보이게 했다.
이 메소드 안에선 replace() 메소드로 프래그먼트를 바꾸게 입력한다.


                                    (2) 트랜잭션 시작
                                    beginTransaction()

                                         ②              ③
    (1) 매니저 참조         ①            →               → 추가        화면 #1
    getFragmentManager()    →       □               □    → 삭제
                                         ←               → 교체
                                         ④
    메인 액티비티                 프래그먼트       트랜잭션            프래그먼트
                                    매니저


메인 액티비티에서 프래그먼트를 다루기 위해 먼저 getFragmentManager() 를 호출하여 매니저 객체를 참조한다.


    public FragmentManager getFragmentManager()


프래그먼트 매니저는 프래그먼트 추가, 삭제, 교체 등 작업을 한다.
프래그먼트 변경 시 오류가 생기면 원래 상태로 돌아갈 수 있도록 트랜잭션 객체를 만들어 실행한다.
트랜잭션 객체는 beginTransaction() 메소드를 호출하여 시작되고 commit() 메소드를 호출하면 실행된다.

이제 앱을 실행하면 처음 보이는 메인 프래그먼트 화면에서 버튼을 누르면 메뉴 프래그먼트 화면으로 전환되는 것을
확인할 수 있다.


        프래그먼트의 수명 주기

플래그먼트 클래스에서 레이아웃 인플레이션할 때 메소드 이름이 onCreateView() 였는데 onCreate() 와 비슷하다.
이는 액티비티처럼 수명 주기를 본따 추가하여 미리 정해둔 코드를 콜백 함수에 따라 실행할 수 있다.

프래그먼트는 액티비티 위에 올라오는 것이라서 수명주기도 액티비티 수명주기에 종속 적이지만
프래그먼트만 가지는 독립적인 상태 정보들도 있다. 특히 onResume() 이나 onPause() 메소드 호출되는데
액티비티에 종속된 상태 메소드 외에 세분화된 상태 메소드가 더 있다.


    onAttach(Activity)              프래그먼트가 액티비티와 연결될 때
    onCreate(Bundle)                프래그먼트가 초기화될 때(new 연산자가 아님)
    onCreateView(LayoutInflator,    프래그먼트와 관련된 뷰 계층을 만들어서 리턴
        ViewGroup, Bundle)
    onActivityCreate(Bundle)        프래그머튼와 액티비티가 onCreate() 메소드 작업을 완료했을 때
    onStart()                       프래그먼트와 연결된 액티비티가 onStart() 되어 사용자에게 프래그먼트가 보일 때
    onResume()                      프래그먼트와 연결된 액티비티가 onResume() 되어 사용자와 상호작용할 수 있을 때


한가지 주의점은 프래그먼트는 액티비티 안에 추가되어 동시에 액티비티에 종속되어 있어 프래그먼트와 액티비티가 연결되어야
초기화될 수 있다. 그래서 new 연산자로 객체를 만든 시점과 onCreate() 로 호출되는 시점이 다르다.
그래서 액티비티를 위한 설정 정보는 onAttach() 메소드에서 처리해야 한다.

다음은 프래그먼트가 화면에서 보이지 않게 될 때 호출되는 상태 메소드들이다.


    onPause()           프래그먼트와 연결된 액티비티가 onPause() 되어 상호작용을 중지할 때
    onStop()            프래그먼트와 연결된 액티비티가 onStop() 되어 더이상 보이지 않거나 기능이 중지됐을 때
    onDestroyView()     프래그먼트와 관련된 뷰 리소스를 해제할 수 있게 호출
    onDestroy()         프래그먼트 상태를 마지막으로 정리
    onDetach()          프래그먼트가 액티비티와 연결을 끊기기 직전에 호출


    액티비티에 프래그먼트 추가      액티비티에서 프래그먼트 제거
            ↓                           ↓
    onAttach()                      onDetach()
            ↓                           ↑
    onCreate()                      onDestroy()
            ↓                           ↑
    onCreateView() <──────────────  onDestroyView()
            ↓                           ↑
    onActivityCreate()                  │
            ↓                           │
    onStart()                       onStop()
            ↓                           ↑
    onResume()                      onPause()
            ↓
        프래그먼트 활성화(액티비티 화면에 보이는 상태)


프래그먼트는 액티비티에 올라가지 않거나 new 연산자로 만들어 올라가기 전까진 동작하지 않는 점을 기억해야한다.


    MyFragment fragment = new MyFragment();
        -> 프래그먼트 객체는 만들어졌지만 동작하지 않음
    getSupportFragmentManager().beginTransaction().add(fragment).commit();
        -> 액티비티에 추가된 후 프래그먼트로 동작함.


            05-2 프래그먼트로 화면 만들기

이번엔 두 프래그먼트가 돌아가게 하자. 화면 위와 아래를 나누어 이미지 선택 가능한 리스트를 프래그먼트로 만들어
선택된 이미지가 보이는 프래그먼트를 만들어 넣는다.

fragment_list.xml 파일을 만들어 세 개의 버튼으로 '첫, 두, 세 번째 이미지' 로 수정한다.
그리고 drawable 에 3개의 이미지를 넣는다.

그다음 ListFragment.java 를 추가하여 다음과 같이 작성한다.


    public class ListFragment extends Fragment {
        public static interface ImageSelectionCallback {
            public void onImageSelected(int position);
        }

        public ImageSelectionCallback callback;

        @Override
        public void onAttach(@NonNull Context context) {
            super.onAttach(context);

            if(context instanceof ImageSelectionCallback) {
                callback = (ImageSelectionCallback) context;
            }
        }

        @Nullable
        @Override
        public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
            ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_list, container, false);
            Button button = rootView.findViewById(R.id.button70);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if(callback != null) {
                        callback.onImageSelected(0);
                    }
                }
            });

            Button button2 = rootView.findViewById(R.id.button71);
            button2.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if(callback != null) {
                        callback.onImageSelected(1);
                    }
                }
            });

            Button button3 = rootView.findViewById(R.id.button71);
            button3.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if(callback != null) {
                        callback.onImageSelected(2);
                    }
                }
            });

            return rootView;
        }
    }


각 버튼 클릭 시 callback 객체의 onImageSelected() 메소드를 호출한다.
onAttach() 메소드로 프래그먼트가 액티비티 위에 올라온 시점에 호출된다.
여기서 callback 변수를 ImageSelectionCallback 인터페이스로 한 이유는 다른 프래그먼트의 이미지를 바꿔주려면
액티비티 쪽에서 데이터 전달해야하니 onImageSelected() 메소드를 정의하여 그 메소드를 호출하도록 한것이다.

매번 액티비티마다 다른 이름의 메소드를 만들면  배먼 무엇인지 확인해야하는 번거로움 때문이다.

만약 메인 액티비티에서 이 인터페이스를 구현했다면 프래그먼트에선 액티비티 참조할 때 인터페이스 타입을 참조한 후
onImageSelected() 메소드를 호출할 수 있다.

이제 이미지를 보여줄 뷰어 프래그먼트를 만든다. fragment_viewer.xml 을 만들어 파일에 ImageView 를 추가한다.

자바 코드는 ViewerFragment.java 를 만들어 다음과 같이 작성한다.


    public class ViewerFragment extends Fragment {
        ImageView imageView;

        @Nullable
        @Override
        public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
            ViewGroup rootView = (ViewGroup) inflater.inflate(R.layout.fragment_viewer, container, false);

            imageView = rootView.findViewById(R.id.imageView7);
            return rootView;
        }

        public void setImage(int resId) {
            imageView.setImageResource(resId);
        }
    }


위와 같이 복잡하지 않으며 setImage() 메소드로 이미지뷰에 이미지를 설정할 수 있게 한다.
이제 메인 액티비티에 두 프래그먼트를 추가해보자.


    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <fragment
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:name="com.example.secondmadang.ListFragment"
            android:id="@+id/listFragment" />

        <fragment
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:name="com.example.secondmadang.ViewerFragment"
            android:id="@+id/viewerFragment" />
    </LinearLayout>


이제 메인 액티비티의 MainActivity5 자바 코드를 작성한다.


    public class MainActivity5 extends AppCompatActivity implements ListFragment.ImageSelectionCallback {
        ListFragment listFragment;
        ViewerFragment viewerFragment;

        int[] images = { R.drawable.aa, R.drawable.asdasd, R.drawable.aaaaaaa };

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main5);

            FragmentManager manager = getSupportFragmentManager();
            listFragment = (ListFragment) manager.findFragmentById(R.id.listFragment);
            viewerFragment = (ViewerFragment) manager.findFragmentById(R.id.viewerFragment);
        }

        @Override
        public void onImageSelected(int position) {
            viewerFragment.setImage(images[position]);
        }
    }


메인 액티비티에서 ImageSelectionCallback 인터페이스를 구현하게 하여 onImageSelected() 메소드를 구현한다.
그 다음 리스트 프래그먼트에서 호출하여 onImageSelected() 메소드로 setImage() 메소드를 호출하여 이미지를 바뀌게 했다.


            05-3 액션바 사용하기


        화면에 메뉴 기능 넣기

안드로이드와 아이폰 차이는 화면 아래 [메뉴] 와 [BACK] 버튼 유무이다. 그래서 시스템 [메뉴] 버튼을 누르면
숨은 메뉴가 보이고 상단 타이틀에 메뉴가 보이도록 할 수도 있다. 이런 메뉴를 옵션 메뉴라 한다.
그리고 옵션 메뉴와 달리 입력 상자를 길게 누르면 나타나는 '복사와 붙여넣기' 등의 팝업 형태의 메뉴는
컨텍스트 메뉴라고 한다. 옵션 메뉴는 각각 화면마다 설정할 수 있고 컨텍스트 메뉴는 뷰마다 설정할 수 있다.


    옵션 메뉴       시스템 [메뉴] 버튼을 눌렀을 때 나타나는 메뉴로 각 화면마다 설정할 수 있는 주요 메뉴다.

    컨텍스트 메뉴   화면을 길게 누르면 나타나는 메뉴로 뷰에 설정하여 나타나게 할 수 있다.
                    텍스트뷰의 편집 상태를 바꾸거나 할 때 사용한다.


옵션 메뉴는 액션바에 포함되어 보이도록 만들어졌으며 앱의 제목이 보이는 위쪽 부분을 말한다.
옵션 메뉴와 컨텍스트 메뉴는 각각의 액티미티마다 설정할 수 있어 두 메소드로 재정의하여 메뉴 아이템을 추가할 수 있다.


    public boolean onCreateOptionsMenu(Menu menu)
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo)


이 두 메소드는 Menu 나 ContextMenu 객체가 전달되는 것을 알 수 있는데 add() 메소드로 아이템을 추가할 수 있다.
대표 메소드는 다음과 같다.


    MenuItem add(int groupId, int itemId, CharSequence title)
    MenuItem add(int groupId, int itemId, int titleRes)
    SubMenu addSubMenu(int titleRes)


groupId 값을 아이템을 하나의 그룹으로 묶을 때 사용한다.
itemId 는 아이템이 갖는 고유 ID 값으로 아이템을 구분할 때 사용할 수 있다.
아이템이 많아 서브 메뉴로 추가하고 싶을 때는 addSubMenu() 메소드를 사용한다.
하지만 이런 코드로 추가하는 것 보다는 XML 메뉴의 속성을 정의하여 객체로 로딩하여 참조하는 것이 더 간단하다.

실습을 위해 메뉴 파일을 만들자. res 폴더에서 리소스타입을 menu 로 하고 menu 폴더를 만든다.
그리고 menu_main.xml 파일을 만들어 <item> 태그로 세 개의 이미지를 추가한다.


    <?xml version="1.0" encoding="utf-8"?>
    <menu xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto">

        <item android:id="@+id/menu_refresh"
            android:title="새로고침"
            android:icon="@drawable/asdasd"
            app:showAsAction="always" />

        <item android:id="@+id/menu_search"
            android:title="검색"
            android:icon="@drawable/aa"
            app:showAsAction="always" />

        <item android:id="@+id/menu_settings"
            android:title="설정"
            android:icon="@drawable/aaaaaaa"
            app:showAsAction="always" />
    </menu>


<item> 태그는 하나의 메뉴에 대한 정보를 담고 있다. icon 속성으로 이미지를 넣을 수도 있고
showAsAction 속성은 이 메뉴가 항상 보일지 숨길지 지정한다.


    showAsAction 속성 값

    always                  항상 액션바에 아이템을 추가하여 표시한다.
    never                   액션바에 아이템을 추가하여 표시하지 않는다.(디폴트)
    ifRoom                  액션바에 여유 공간이 있으면 아이템을 표시
    withText                title 속성으로 설정된 제목을 같이 표시
    collapseActionView      아이템에 설정한 뷰의 아이콘만 표시


매인 액티비티에 재정의된 onCreateOptionsMenu() 메소드로 액티비티가 만들어질 때 자동 호출되어
메뉴 기능을 추가할 수 있게 한다. 만든 메뉴 XML 파일은 레이아웃 파일처럼 인플레이션한 후 메뉴에 설정할 수 있다.
XMl 정보를 메모리에 로딩하기 위해 메뉴 인플레이터 객체를 사용한다.
MainActivity6 파일에서 다음과 같이 작성한다.


    public class MainActivity6 extends AppCompatActivity {
        @Override
        public boolean onCreateOptionsMenu(Menu menu) {
            getMenuInflater().inflate(R.menu.menu_main, menu);
            return true;
        }

        @Override
        public boolean onOptionsItemSelected(@NonNull MenuItem item) {
            int curId = item.getItemId();
            switch(curId) {
                case R.id.menu_refresh:
                    Toast.makeText(this, "새로고침 메뉴가 선택되었습니다", Toast.LENGTH_SHORT).show();
                    break;
                case R.id.menu_search:
                    Toast.makeText(this, "검색 메뉴가 선택되었습니다.", Toast.LENGTH_SHORT).show();
                    break;
                case R.id.menu_settings:
                    Toast.makeText(this, "설정 메뉴가 선택되었습니다.", Toast.LENGTH_SHORT).show();
                    break;
                default:
                    break;
            }

            return super.onOptionsItemSelected(item);
        }
    }


화면이 처음 만들어지면 메뉴를 정하는 것이 아닌 화면이 띄워진 후 PrepareOptionsMenu() 메소드를 재정의하여 사용하면 된다.
이 메소드는 메뉴가 새로 보일 때마다 호출되어 메뉴 항목을 추가하거나 뺄 수 있어 메뉴 아이템들을 변경할 수 있다.
특히 메뉴를 활성화, 비활성화하여 사용하거나 못사용하게 할 수 있다.

메뉴 선택 처리도 간단하며 메뉴 아이템을 선택했을 때 자동 호출되는 onOptionsItemSelected() 메소드를 재정의하여
현재 메뉴 아이템의 id 값이 무엇인지 확인하여 맞는 기능을 만들면된다.


    onOptionsItemSelected(MenuItem item)


컨텍스트 메뉴는 어느 뷰에 필요한 기능만 모아 정의한 것으로 손가락으로 길게 누르면 보이게 된다.
컨텍스트 메뉴도 두 메소드를 재정의하여 사용할 수 있다. 컨텍스트 등록은 registerForContextMenu() 메소드를 사용한다.


    void Activity.registerForContextMenu(View view)


이 메소드로 컨텍스트 메뉴를 등록하면 각 메뉴 아이템 선택 시 onContextItemSelected() 메소드가 호출되어
파라미터로 전달되는 MenuItem 객체를 사용하여 정보 확인 후 처리할 수 있다.


        액션바 더 살펴보기

모든 액션바는 제목을 보여주는 타이틀 기능을 하여 앱 제목을 보여줄 수 있고
화면에 보이거나 안보일 수 있다. 보이게하고 싶다면 show() 반대로 hide() 로 숨길 수 있다.


    ActionBar abar = getActionBar();
    abar.show();
    abar.hide();


setSubtitle() 메소드를 사용하면 타이틀의 부제목을 달아줄 수도 있다. 화면에 대한 구체적 설명 같은 것을 보일때 유용하다.
앱을 디폴트 설정 그대로 실행하면 액션바 왼쪽에 아무것도 보이지 않지만 설정을 바꾸면 아이콘이 보이게할 수도 있다.

액션바를 다루기 위해 action_bar.xml 파일을 만들어 '액션바 아이콘 바꾸기' 라는 버튼과 텍스트뷰를 추가한다.
그리고 ActionBarActivity 자바 파일은 다음과 같이 작성한다.


    public class ActionBarActivity extends AppCompatActivity {
        ActionBar abar;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.action_bar);

            abar = getSupportActionBar();

            Button button = findViewById(R.id.button73);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    abar.setLogo(R.drawable.aa);
                    abar.setDisplayOptions(ActionBar.DISPLAY_SHOW_HOME|ActionBar.DISPLAY_USE_LOGO);
                }
            });
        }

        @Override
        public boolean onCreateOptionsMenu(Menu menu) {
            ...


ActionBar 는 androidx.appcompat.app 패키지의 클래스며 onCreate() 메소드에서 getSupportActionBar() 메소드로
XML 레이아웃의 ActionBar 를 참조할 수 있다. 직접 XML 으로 추가하거나 액티비티에서 적용한 테마로 자동으로 부여할 수 있다.
setDisplayOptions() 메소드로 미리 정의된 상수 파라미터를 전달하여 모양을 바꿀 수 있다.


    디스플레이옵션 상수

    DISPLAY_USE_LOGO        홈 아이콘 부분에 로고 아이콘을 사용한다.
    DISPLAY_SHOW_HOME       홈 아이콘 표시
    DISPLAY_HOME_AS_UP      홈 아이콘에 뒤로가기 모양 < 같은 아이콘 표시
    DISPLAY_SHOW_TITLE      타이틀을 표시


위 로고 아이콘은 매니페스트에 등록된 액티비티의 속성으로 지정할 수도 있다.
실행 시 위쪽의 액션바에 두 개의 메뉴 아이콘이 표시된다.


앞의 메뉴 XML 파일을 다시 살펴보자. <item> 태그 속성의 showAsAction 속성에 각각
'always', 'always|withText', 'never' 로 설정해보자. 추가로 orderInCategory 도 더한다.
이 속성은 메뉴가 보이는 순서를 101, 102, 103 처럼 숫자 순으로 지정한다.

이와같이 액션바도 약간씩 조정할 수 있어 다양하게 표현할 수 있다.

이번엔 액션바에 검색어를 입력할 수 있는 입력상자를 넣어보자.
search_layout.xml 파일을 만들어 다음과 같이 작성한다.


    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="검색"
            android:textSize="16sp"
            android:textColor="#ffad8745" />

        <EditText
            android:id="@+id/editText5"
            android:layout_width="100dp"
            android:layout_height="wrap_content"
            android:layout_marginLeft="4dp"
            android:inputType="text"
            android:imeActionId="1337"
            android:imeOptions="actionDone" />
    </LinearLayout>


이엏게 만든 레이아웃을 액션바에 넣어서 보여주려면 액션바에 추가된 메뉴 아이템 중 하나로 보이게해야 한다.
먼저 메뉴 파일의 레이아웃에 다음 코드를 추가한다.


    <item android:id="@+id/menu_search1"
        android:title="검색"
        android:orderInCategory="102"
        app:showAsAction="always|withText"
        android:actionLayout="@layout/search_layout" />


그 다음 메인 액티비티 자바 파일을 열어서 EditText 객체를 사용자가 검색어를 입력하고 '완료' 키를 눌렀을 때
원하는 기능이 수행되게 코드를 수정한다.


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.menu_main, menu);

        View v = menu.findItem(R.id.menu_search1).getActionView();
        if (v != null) {
            EditText editText = v.findViewById(R.id.editText5);

            if (editText != null) {
                editText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
                    @Override
                    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
                        Toast.makeText(getApplicationContext(), "입력됨", Toast.LENGTH_SHORT).show();
                        return true;
                    }
                });
            }
        }

        return true;
    }


            05-4 상단 탭과 하단 탭


        상단 탭 보여주기

모바일은 크기가 작아 많은 화면 메뉴는 사용성에 좋지 않다. 그래서 화면 액티비티를 최대한 분리하는 것이 좋다.

때로 여러 구성 요소를 두고 전환하여 보여줄 때도 좋으며 대표적으로 서브 화면들이다.
상단의 버튼을 누르면 다른 화면을 보여주는 방식으로 전환하여 보여줄 수 있다.

몇몇 버튼 중 탭을 보여주는 것도 있을 수 있다. 상단 탭을 누르면 화면 영역이 전환되어 나타나
탭은 내비게이션 위젯이라고도 불리며 상단 탭과 하단 탭으로 구분된다.

상단 탭을 만들기 위해 sample_tab.xml 파일을 만들어 다음과 같이 작성한다.


    <?xml version="1.0" encoding="utf-8"?>
    <RelativeLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <androidx.coordinatorlayout.widget.CoordinatorLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent" >
            <com.google.android.material.appbar.AppBarLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:theme="@style/ThemeOverlay.AppCompat.ActionBar" >

                <androidx.appcompat.widget.Toolbar
                    android:id="@+id/toolbar"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:background="@color/design_default_color_primary_dark"
                    android:elevation="1dp"
                    android:theme="@style/ThemeOverlay.AppCompat.Dark">

                    <TextView
                        android:id="@+id/titleText"
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="타이틀"
                        android:textAppearance="@style/TextAppearance.AppCompat.Widget.ActionBar.Title" />
                </androidx.appcompat.widget.Toolbar>

                <com.google.android.material.tabs.TabLayout
                    android:id="@+id/tabs"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:background="@android:color/background_light"
                    android:elevation="1dp"
                    app:tabGravity="fill"
                    app:tabMode="fixed"
                    app:tabSelectedTextColor="@color/design_default_color_primary_variant"
                    app:tabTextColor="@color/design_default_color_primary" />
            </com.google.android.material.appbar.AppBarLayout>

            <FrameLayout
                android:id="@+id/container2"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                app:layout_behavior="@string/appbar_scrolling_view_behavior">

            </FrameLayout>
        </androidx.coordinatorlayout.widget.CoordinatorLayout>
    </RelativeLayout>


내용이 많지만 줄여본다면 다음과 같다.


    <CoordinatorLayout>
        <AppBarLayout>
            <Toolbar>
            </Toolbar>
            <TabLayout>
            </TabLayout>
        </AppBarLayout>
        <FrameLayout>
        </FrameLayout>
    </CoordinatorLayout>


CoordinatorLayout 는 액션바 영역의 전체 화면 위치를 잡는 역할이다.
이 안에 AppBarLayout 와 함께 다른 레이아웃을 넣어 간격이나 위치를 결정한다.

AppBarLayout 는 액션바를 가리키는데 이 안에 Toolbar 를 넣을 수 있고, 탭을 사용할 경우
탭 버튼이 들어갈 TabLayout 을 추가할 수 있다. 아래엔 FrameLayout 을 넣어 화면 내용을 구성할 수 있다.

Toolbar 안에는 텍스트뷰를 넣어서 제목을 표시할 수 있게 한다. TabLayout 엔 여러 속성 중
tabMode 값을 fixed 로 하고 tabGravity 값을 fill 로 설정하여 [탭] 버튼들이 동일한 크기를 갖게할 수 있다.

FrameLayout 은 id 를 지정하여 자바 코드에서 프래그먼트를 넣을 수 있게 한다.

탭은 세 개를 만들 것이며 각 탭을 누르면 다른 내용이 보여야한다.
액티비티는 그중 일부분만 화면이 변경되게 하며 프래그먼트를 사용한다.
FrameLayout 하단 공간을 확보한 후 서로 다른 프래그먼트를 넣어본다.

먼저 fragment1.xml 파일을 만들어 LinearLayout 레이아웃에 버튼을 '첫 번째' 로 하나 추가한다.
다른 프래그먼트와 구분되도록 배경색도 지정한다.

그리고 첫 번째 프래그먼트의 자바 코드는 Fragment1.java 로 만들어 다음과 같이 작성한다.


    public class Fragment1 extends Fragment {
        @Nullable
        @Override
        public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
            return inflater.inflate(R.layout.fragment1, container, false);
        }
    }


두 파일도 동일하게 XML, Fragment2, 3.java 으로 만들어 생성한다.


    public class MainActivity7 extends AppCompatActivity {
        Toolbar toolbar;

        Fragment1 fragment1;
        Fragment2 fragment2;
        Fragment3 fragment3;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_tab);

            toolbar = findViewById(R.id.toolbar);
            setSupportActionBar(toolbar);

            ActionBar actionBar = getSupportActionBar();
            actionBar.setDisplayShowTitleEnabled(false);

            fragment1 = new Fragment1();
            fragment2 = new Fragment2();
            fragment3 = new Fragment3();

            getSupportFragmentManager().beginTransaction().replace(R.id.container2, fragment1).commit();
        }
    }


XML 에 정의한 Toolbar 는 setSupportActionBar() 메소드로 설정해야 한다.
Toolbar 클래스는 여러 개인데 androidx.appcompat.widget 패키지의 Toolbar 를 임포트한다.
setSupportActionBar() 메소드는 액티비티에 디폴트 액션바가 없을 때만 동작하는데
프로젝트 생성 시 자동으로 액션바가 만들어진다. 이것은 테마를 액션바가 있는 테마로 설정했기 때문이다.
테마를 변경하기 위해 'app/res/values' 폴더에 styles(themes).xml 파일을 연다.
<style> 태그에 parent 속성을 수정하자.


    <style name="Theme.SecondMadang" parent="Theme.AppCompat.NoActionBar">


NoActionBar 로 선택하면 기본 액션바가 만들어지지 않는다.
그래서 setSupportActionBar() 메소드를 호출하여 직접 액션바를 설정할 수 있다.
이제 세 개의 프래그먼트 객체를 화면에 보이게 해보자.



        fragment1 = new Fragment1();
        fragment2 = new Fragment2();
        fragment3 = new Fragment3();

        getSupportFragmentManager().beginTransaction().replace(R.id.container2, fragment1).commit();

        TabLayout tabs = findViewById(R.id.tabs);
        tabs.addTab(tabs.newTab().setText("통화기록"));
        tabs.addTab(tabs.newTab().setText("스팸기록"));
        tabs.addTab(tabs.newTab().setText("연락처"));

        tabs.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() {
            @Override
            public void onTabSelected(TabLayout.Tab tab) {
                int position = tab.getPosition();
                Log.d("MainActivity", "선택된 탭 : " + position);

                Fragment selected = null;
                if(position == 0) {
                    selected = fragment1;
                } else if(position == 1) {
                    selected = fragment2;
                } else if (position == 2) {
                    selected = fragment3;
                }

                getSupportFragmentManager().beginTransaction().replace(R.id.container2, selected).commit();
            }

            @Override
            public void onTabUnselected(TabLayout.Tab tab) {

            }

            @Override
            public void onTabReselected(TabLayout.Tab tab) {

            }
        });
    }


TabLayout 에 addTab() 메소드로 [탭] 버튼을 추가할 수 있다. 그리거 OnTabSelectedListener 를 설정할 수 있는데
이 리스너는 탭 버튼 선택될 때마다 onTabSelected() 메소드가 호출되도록 한다.


        하단 탭 보여주기

하단 탭은 BottomNavigationView 위젯으로 만들 수 있다. 이 위젯도 머티리얼 라이브러리르 사용한다.
menu 폴더에 menu_bottom.xml 파일을 만들어 다음 코드를 추가한다.


    <?xml version="1.0" encoding="utf-8"?>
    <menu xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto">

        <item
            android:id="@+id/tab1"
            app:showAsAction="ifRoom"
            android:enabled="true"
            android:icon="@android:drawable/ic_dialog_email"
            android:title="이메일" />

        <item
            android:id="@+id/tab2"
            app:showAsAction="ifRoom"
            android:icon="@android:drawable/ic_dialog_info"
            android:title="정보" />

        <item
            android:id="@+id/tab3"
            app:showAsAction="ifRoom"
            android:enabled="true"
            android:icon="@android:drawable/ic_dialog_map"
            android:title="위치" />
    </menu>


이후 sample_tab2.xml 파일을 만들어 다음과 같이 작성한다.


    <?xml version="1.0" encoding="utf-8"?>
    <androidx.constraintlayout.widget.ConstraintLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <FrameLayout
            android:id="@+id/container3"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            app:layout_behavior="@string/appbar_scrolling_view_behavior" />

        <com.google.android.material.bottomnavigation.BottomNavigationView
            android:id="@+id/bottom_navigation"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginEnd="0dp"
            android:layout_marginStart="0dp"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:itemBackground="@color/design_default_color_primary"
            app:itemIconTint="@color/design_default_color_primary_dark"
            app:itemTextColor="@color/design_default_color_primary_variant"
            app:menu="@menu/menu_bottom" />
    </androidx.constraintlayout.widget.ConstraintLayout>


하단 탭의 위젯은 BottomNavigationView 이므로 화면의 화단에 표시될 수 있게 ConstraintLayout 안에 넣었다.
화면 전체는 FrameLayout 이 차지하게 하였다.

각 탭을 눌렀을 때 해당 프레임 레이아웃의 프래그먼트를 바꿔가며 보여줘야 한다.
이전의 fragment1, 2, 3 파일들을 활용한다. MainActivity8 자바 소스를 다음과 같이 작성한다.


    public class MainActivity8 extends AppCompatActivity {
        Fragment1 fragment1;
        Fragment2 fragment2;
        Fragment3 fragment3;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_tab2);

            fragment1 = new Fragment1();
            fragment2 = new Fragment2();
            fragment3 = new Fragment3();

            getSupportFragmentManager().beginTransaction().replace(R.id.container3, fragment1).commit();

            BottomNavigationView bottomNavigation = findViewById(R.id.bottom_navigation);
            bottomNavigation.setOnNavigationItemSelectedListener(
                    new BottomNavigationView.OnNavigationItemSelectedListener() {
                        @Override
                        public boolean onNavigationItemSelected(@NonNull MenuItem item) {
                            switch (item.getItemId()) {
                                case R.id.tab1:
                                    Toast.makeText(getApplicationContext(), "첫 번째 탭 선택됨", Toast.LENGTH_SHORT).show();
                                    getSupportFragmentManager().beginTransaction().replace(R.id.container3, fragment1).commit();

                                    return true;
                                case R.id.tab2:
                                    Toast.makeText(getApplicationContext(), "두 번째 탭 선택됨", Toast.LENGTH_SHORT).show();
                                    getSupportFragmentManager().beginTransaction().replace(R.id.container3, fragment2).commit();

                                    return true;
                                case R.id.tab3:
                                    Toast.makeText(getApplicationContext(), "셋 번째 탭 선택됨", Toast.LENGTH_SHORT).show();
                                    getSupportFragmentManager().beginTransaction().replace(R.id.container3, fragment3).commit();

                                    return true;
                            }

                            return false;
                        }
                    }
            );
        }
    }


            05-5 뷰 페이저 만들기

뷰페이저는 손가락으로 좌우 스크롤로 넘기는 기능을 제공한다.
뷰페이저는 안의 프래그먼트를 넣어 좌우 스크롤로 프래그먼트를 전환할 수 있다.
내부에서 어댑터라는 것과 상호작용하게 되어 여러 아이템 중 하나를 보여주는 방식으로 동작한다.

실습을 위해 sample_pager.xml 을 만들어 리니어를 orientation 속성을 vertical 로 하고 버튼 하나와
ViewPager 도 끌어 넣고 pager 아이디를 부여한다.

프래그먼트는 이전에 만든 fragment1, 2, 3 을 활용한다.


    public class MainActivity9 extends AppCompatActivity {
        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_pager);
        }

        class MyPagerAdapter extends FragmentStatePagerAdapter {
            ArrayList<Fragment> items = new ArrayList<>();
            public MyPagerAdapter(FragmentManager fm) {
                super(fm);
            }

            public void addItem(Fragment item) {
                items.add(item);
            }

            @NonNull
            @Override
            public Fragment getItem(int position) {
                return items.get(position);
            }

            @Override
            public int getCount() {
                return items.size();
            }
        }
    }


MyPagerAdapter 클래스는 내부 클래스로 FragmentStatePagerAdapter 를 상속했다.
뷰페이저에 보여줄 각 프래그먼트를 관리하며 서로 상호작용하여 표시해주게 된다.
그리고 ArrayList 객체로 프래그먼트를 추가하였다.
이제 이 어댑터를 사용할 수 있게 onCreate() 메소드에 추가한다.


    public class MainActivity9 extends AppCompatActivity {
        ViewPager pager;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_pager);

            pager = findViewById(R.id.pager);
            pager.setOffscreenPageLimit(3);

            MyPagerAdapter adapter = new MyPagerAdapter(getSupportFragmentManager());

            Fragment1 fragment1 = new Fragment1();
            adapter.addItem(fragment1);

            Fragment2 fragment2 = new Fragment2();
            adapter.addItem(fragment2);

            Fragment3 fragment3 = new Fragment3();
            adapter.addItem(fragment3);

            pager.setAdapter(adapter);
        }


레이아웃의 ViewPager 객체를 findViewById() 로 찾아 할당 후 setOffscreenPageLimit() 로 아이템 개수를 세 개로
지정했다.

만약 사용자가 손가락으로 전환하지 않고 코드에서 전환시키고 싶다면 뷰페이저 객체의 setCurrentItem() 메소드를 사용하면 된다.
뷰페이저 위의 버튼 글자를 '두 번째 화면 보여주기' 로 수정하고 버튼 이벤트를 처리한다.


    Button button = findViewById(R.id.button77);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            pager.setCurrentItem(1);
        }
    });


다시 앱을 실행하고 버튼으로 전환해보자.
이런 뷰페이지는 몇 번째 것인지 알기 어렵기 때문에 어느 아이템인지 보여줄 필요가 있다.
이런 역할을 하는 것이 타이틀스트립(TitleScrip)이다.
타이틀 스트립 외에 탭스트립을 사용할 수도 있는데 이 경우엔 탭 모양으로 아이템을 구분하여 보여준다.

타이틀스트립을 추가해보자. sample_pager.xml 을 열어 PagerTitleStrip 객체를 ViewPager 안에 추가해보자.


    <androidx.viewpager.widget.ViewPager
        android:id="@+id/pager"
        android:layout_width="match_parent"
        android:layout_height="match_parent" >

        <androidx.viewpager.widget.PagerTitleStrip
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="#55cedf"
            android:paddingTop="5dp"
            android:paddingBottom="5dp">

        </androidx.viewpager.widget.PagerTitleStrip>

    </androidx.viewpager.widget.ViewPager>


이제 메인 액티비티 자바 코드에서 MyPagerAdapter 클래스 마지막에 getPageTitle() 메소드를 추가한다.


    @Nullable
    @Override
    public CharSequence getPageTitle(int position) {
        return "페이지" + position;
    }


            05-6 바로가기 메뉴

좌측 상단의 메뉴를 누르면 네비게이션바가 나타나는 기능은 NavigationDrawer 란 이름으로 불린다.
바로가기 메뉴는 몇 개의 화면에서 공통으로 보여줄 수 있어 빠르게 메뉴 기능에 접근하고자할 때 사용한다.
또는 로그인 정보나 설정 메뉴를 보여줄 수도 있다.

가장 쉬운 방법으로는 프로젝트 만들 때 선택 시 Navigation Drawer Activity 를 선택하여 만드는 것이다.

이렇게 프로젝트를 만들고 매니페스트 파일을 보면 <activity> 태그에 기본 테마가 아닌 커스텀 테마를 설정하기
위해서 다음 설정이 있다.


    <activity
        android:name=".MainActivity"
        android:label="@string/app_name"
        android:theme="@style/Theme.MyApplication.NoActionBar">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />

            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>


바로 @style/Theme.MyApplication.NoActionBar 설정이다. 이번엔 theme.xml 파일을 열어보자.


    <style name="Theme.MyApplication.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
    </style>


테마 파일에도 NoActionBar 설정을 확인할 수 있다. 그리고 이 내용들은 모두 별도 파일들로 분리되어 있다.
모두 통합되면 코드 확인이 더 편할 수 있기 때문에 하나로 통합한다.
navigation.xml 파일을 만들어 다음과 같이 통합한다.


    <?xml version="1.0" encoding="utf-8"?>
    <androidx.drawerlayout.widget.DrawerLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:id="@+id/drawer_layout"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:fitsSystemWindows="true"
        tools:openDrawer="start">

        <androidx.coordinatorlayout.widget.CoordinatorLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent">

            <com.google.android.material.appbar.AppBarLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:theme="@style/Theme.MyApplication.AppBarOverlay">

                <androidx.appcompat.widget.Toolbar
                    android:id="@+id/toolbar1"
                    android:layout_width="match_parent"
                    android:layout_height="?attr/actionBarSize"
                    android:background="?attr/colorPrimary"
                    app:popupTheme="@style/Theme.MyApplication.PopupOverlay" />

            </com.google.android.material.appbar.AppBarLayout>

            <FrameLayout
                android:id="@+id/container4"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                app:layout_behavior="@string/appbar_scrolling_view_behavior">

            </FrameLayout>

        </androidx.coordinatorlayout.widget.CoordinatorLayout>

        <com.google.android.material.navigation.NavigationView
            android:id="@+id/nav_view"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:layout_gravity="start"
            android:fitsSystemWindows="true"
            app:headerLayout="@layout/nav_header_main"
            app:menu="@menu/activity_main_drawer" />
    </androidx.drawerlayout.widget.DrawerLayout>


단순화를 위해 FloatingActionButton 은 삭제 했다. 그리고 AppBarLayout 의 아래쪽엔 FrameLayout 태그를 추가했다.
원래 ConstraintLayout 이지만 FrameLayout 으로 바꿔도 된다. 이 레이아웃 속성에 app:layout_behavior 속성이 부여됐는데
이로 인해 CoordinatorLayout 안에서 해당 레이아웃이 스크롤 등의 작업이 진행될 때 차지할 면적을 자동으로 계산하게 한다.
이 FrameLayout 의 fragment 는 삭제하였다.

NavigationView 객체엔 headerLayout 속성과 menu 속성을 넣어 메뉴 상단에 표시되어 사용자 프로필 등을 보여주도록
하였고 menu 속성으로 아래 메뉴가 보이도록 했다.

메이나 화면으로 보일 FrameLayout 안에 프래그먼트 세 개를 상태에 맞게 전환하면서 보여줄 것이므로
이전에 만들었던 fragment 1, 2, 3 을 그대로 사용한다.


    public class MainActivity10 extends AppCompatActivity implements
            NavigationView.OnNavigationItemSelectedListener, FragmentCallback {
        Fragment1 fragment1;
        Fragment2 fragment2;
        Fragment3 fragment3;

        DrawerLayout drawer;
        Toolbar toolbar;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.navigation);

            toolbar = findViewById(R.id.toolbar1);
            setSupportActionBar(toolbar);

            drawer = findViewById(R.id.drawer_layout);
            ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(
                    this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);
            drawer.addDrawerListener(toggle);
            toggle.syncState();

            NavigationView navigationView = findViewById(R.id.nav_view);
            navigationView.setNavigationItemSelectedListener(this);

            fragment1 = new Fragment1();
            fragment2 = new Fragment2();
            fragment3 = new Fragment3();

            getSupportFragmentManager().beginTransaction().replace(R.id.container4, fragment1).commit();
        }

        @Override
        public void onBackPressed() {
            if(drawer.isDrawerOpen(GravityCompat.START)) {
                drawer.closeDrawer(GravityCompat.START);
            } else {
                super.onBackPressed();
            }
        }

        @Override
        public boolean onNavigationItemSelected(@NonNull MenuItem item) {
            int id = item.getItemId();

            if(id == R.id.menu1) {
                Toast.makeText(this, "첫 번째 메뉴 선택됨", Toast.LENGTH_SHORT).show();
                onFragmentSelected(0, null);
            } else if (id == R.id.menu2) {
                Toast.makeText(this, "두 번째 메뉴 선택됨", Toast.LENGTH_SHORT).show();
                onFragmentSelected(1, null);
            } else if (id == R.id.menu3) {
                Toast.makeText(this, "세 번째 메뉴 선택됨", Toast.LENGTH_SHORT).show();
                onFragmentSelected(2, null);
            }

            return true;
        }

        @Override
        public void onFragmentSelected(int position, Bundle bundle) {
            Fragment curFragment = null;

            if(position == 0) {
                curFragment = fragment1;
                toolbar.setTitle("첫 번째 화면");
            } else if(position == 1) {
                curFragment = fragment2;
                toolbar.setTitle("두 번째 화면");
            } else if (position == 2) {
                curFragment = fragment3;
                toolbar.setTitle("세 번째 화면");
            }

            getSupportFragmentManager().beginTransaction().replace(R.id.container4, curFragment).commit();
        }
    }


FragmentCallback 인터페이스는 어느 프래그먼트를 보여줄 지 선택하는 메소드를 포함하고 있다.


    public interface FragmentCallback {
        public void onFragmentSelected(int position, Bundle bundle);
    }


바로가기 메뉴도 메뉴를 누르면 onNavigationItemSelected() 메소드가 호출되게 했다.
그래서 어느 메뉴가 눌린 것인지 onFragmentSelected() 메소드를 호출하여 해당 화면으로 표시하게 했다.
onBackPressed() 메소드는 시스템 [BACK] 키를 누르면 바로가기 메뉴가 열여있다면 닫는 코드가 추가되었다.

바로가기 메뉴 화면에 들어가는 메뉴들을 각각 menu 1, 2, 3 으로 수정하고 확인해보자.