            03-1 기본 위젯 복습


        텍스트 뷰

기본 위젯으로 글자를 보여준다.


    텍스트 뷰 text 속성

문자열을 설정할 수 있으며 이 속성은 반드시 지정해야 한다. 텍스트뷰에 문자열이 없으면 차지하는 영역도 알 수 없기 때문이다.
'res/values' 폴더에 strings.xml 파일을 작성한 문자열을 지정하는 방법이 있다.

지금까지는 디자인 창에서 text 속성을 변경했지만 strings.xml 파일에 문자열을 미리 작성하여 이 값을 지정하는 방법을
더 권장한다. 이는 text 문자열을 따로 분리할 수 있고 다국어 지원이 필요할 때 한국어, 영어, 일본어 등의
레이아웃을 만드는 것보다 strings.xml 파일로 언어별로 만드는 것이 더 효율적이기 때문이다.

values 폴더의 strings.xml 파일에 <string> 태그로 더 작성해보자.


    <resources>
        <string name="app_name">Second Madang</string>
        <string name="person_name">조원용</string>
    </resources>


<string> 문자열을 텍스트 뷰에 나오게 해보자. strings_activity.xml 파일을 만든다.
텍스트 뷰의 text 속성을 찾아 @string/person_name 을 입력해보자.


    조언

    다국어 지원하는 방식은 병렬 리소스 로딩 방식을 이용한다.
    예로 영어와 한국어를 지원하는 앱을 만들고 싶다면 'res/values-en' 과 '/res/values-ko' 를 만들어
    각각의 파일에 strings.xml 파일을 만든다.


strings 에 정의된 문자열은 text 속성에서 @string/.. 방식을 잊지말자.


    텍스트뷰의 textColor 속성

textColor 속성은 텍스트뷰에서 표시하는 문자열의 색상을 설정한다.
일반적으로 '#AARRGGBB' 포맷으로 한다. Alpha(투명도), Red, Green, Blue 순을 잊지말자.


    텍스트뷰의 textSize 속성

폰트 크기는 'dp', 'sp' 또는 'px' 를 사용할 수 있고 'sp' 단위를 권장한다.
단말도 해상도에 따라 글자 크기를 일정한 크기를 보여줄 수 있다.


    textStyle

"nomal", "bold", "italic" 등의 값을 지정할 수 있고 | 기호를 사용하면 여러 속성값을 지정할 수 있다.
이때 | 기호 앞에 공백이 있으면 안된다.


    typeFace

typeFace 속성은 텍스트뷰에서 표시하는 문자열의 폰트를 설정한다. 기본으로 제공되는 폰트는 개수가 많진 않지만
그 중 하나를 사용할 수 있다. "normal", "sans", "serif", "monospace" 중 하나를 지정할 수 있다.


    maxLines

이 속성은 텍스트뷰에 표시하는 문자열의 최대 줄 수 이다. 특히 한줄로 표시하고 싶다면
값을 "1" 로 설정하면 된다. 이렇게 한 줄의 영역을 넘어가는 부분은 표시되지 않을 수 있다.


    <TextView
        android:id="@+id/textView18"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="#88aabbff"
        android:padding="4dp"
        android:text="여기에 사용자 이름을 입력하세요. 이름은 한 줄로 표시됩니다."
        android:textSize="40sp"
        android:textStyle="bold"
        android:maxLines="1"
        android:gravity="center"
        />


이렇게 텍스트를 한줄로 표시하게 하면 글자가 모두 보이지 않는 것을 알 수 있다.


        버튼

버튼은 클릭시 반응을 위한 위젯으로 텍스트뷰를 상속하여 정의되어 있다.
그래서 text, textColor 등 텍스트뷰의 속성도 그대로 가지고 있다.

또한 다양한 버튼을 제공하며 체크 박스, 라디오버튼 등으로 다양하다.
그리고 버튼을 클릭했을 때의 이벤트는 간단하게 onClickListener 를 정의하여 버튼에 설정하는 것이다.

체크 박스와 라이도 버튼은 단순히 클릭 이벤트만 처리하는 것이 아니라 상태 값을 저장하고 선택/해제 상태를 표시할 수 있다.
이런 작업이 가능하게 CompoundButton 클래스가 정의되어 있는데 이 클래스는 다음 메소드를 포함하고 있다.


    public boolean isChecked()
    public void setChecked(boolean checked)
    public void toggle()


살펴본 메소드엔 체크 박스, 라디오 버튼이 선택되어 있는 지 확인하는 메소드는 isChecked() 이고
체크 상태를 지정하는 메소드는 setChecked() 이다. 만약 버튼의 상태가 바뀌는 것을 알고 싶다면 다음 메소드를 재정의하면 된다.


    void onCheckedChanged(CompoundButton buttonView, boolean isChecked)


라디오 버튼은 하나의 버튼이 선택되면 다른 버튼의 선택이 해제된다.
이런 기능을 구현하기 위해 RadioGroup 을 이용해 라디오 버튼을 하나의 그룹으로 묶어준다.

실습을 위해 buttons.xml 파일을 만들자. 그후 각종 버튼들을 추가한다.


    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <Button
            android:id="@+id/button35"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="선택"
            android:textSize="24sp"
            android:textStyle="bold"
            android:gravity="center"/>

        <RadioGroup
            android:id="@+id/radioGroup01"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <RadioButton
                android:id="@+id/radioButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:textStyle="bold"
                android:text="남성" />

            <RadioButton
                android:id="@+id/radioButton2"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:textStyle="bold"
                android:text="여성" />

        </RadioGroup>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center_vertical|center_horizontal"
            android:layout_weight="1"
            android:orientation="horizontal">

            <TextView
                android:id="@+id/textView19"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="하루종일" />

            <CheckBox
                android:id="@+id/checkBox"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content" />
        </LinearLayout>

    </LinearLayout>


기본 버튼 아래 RadioGroup 을 추가하고 그 안에 두 개의 RadioButton 을 추가하여 그룹화했다.
그 아레 LinearLayout 으로 텍스트뷰와 CheckBox 를 추가했다.


    에디트텍스트

입력상자 역할을 하는 에디트텍스트는 사용자에게 값을 입력받을 때 사용한다.
이 위젯은 글자를 입력하려고 커서를 옮기면 키패드가 화면에 나타난다. 그리고 화면, 영문, 숫자 등 입력할 수 있다.

edittext.xml 을 만들어서 에디트텍스트를 추가해보자.


    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <EditText
            android:id="@+id/editTextTextPersonName"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:ems="10"
            android:inputType="textPersonName"
            android:text="Name" />
    </LinearLayout>


        이미지뷰와 이미지 버튼

이미지 버튼은 이미지를 화면에 표시할 때 사용하는 가장 간단한 위젯이다.
두 위젯의 차이점은 버튼처럼 사용할 수 있다는 점 이외엔 없다.
이미지뷰에 이미지를 나타내려면 먼저 'res/drawable' 폴더에 저장한 이미지를 app:srcCompat 속성으로 지정하는 방법이다.


    @drawable/이미지파일명


이때 확장자명은 제외하고 작성해야 한다. 이런 방식을 '이미지 리소스 지정 방식' 이라 한다.
이 파일을 자바에서 비트맵으로 만든 후 설정하는 방법도 있다. 대표 속성들은 다음과 같다.


    android:src 또는 app:srcCompat

android:src 나 srcCompat 속성은 원본 이미지를 설정한다. 텍스트뷰에 text 속성을 설정하지 않으면
뷰의 내용물이 설정되지 못해 뷰의 크기를 확인할 수 없다. 이처럼 이미지뷰는 이미지 지정되지 않으면
이미지뷰의 크기를 확인할 수 없다. 그래서 속성은 반드시 설정해야 한다.
확장자는 JPG, PNG 등이며 PNG 을 권장한다.


    maxWidth, maxHeight

두 속성은 이미지 표시의 최대 폭, 높이를 설정한다. 이 속성을 설정하지 않으면 원본 이미지 그대로 나타난다.
원본이 너무 크면 이 속성으로 최대 크기를 지정할 수 있다.


    tint

이미지 색상을 설정할 수 있다. 색상을 '#AARRGGBB' 포맷으로 적용할 수 있고
원본 이미지와 다른 느낌을 주거나 반투명하게 할 수 있다.


    scaleType

scaleType 속성은 이미지뷰의 크기에 맞춰 원본 이미지 크기를 자동으로 늘리거나 줄여서 보여줄 때 사용한다.
원본 이미지를 늘리거나 줄이는 것이 아닌 원하는 형태로 확대하거나 축소할 수 있다.
이 속성엔 fixXY, centerCrop, centerInside 등의 이미지 변환 알고리즘이 적용된 미리 정의된 값을
사용할 수 있으며, 필요에 따라 적절하게 적용하면 된다.


    조언  drawable 제대로된 사용

    안드로이드는 화면 해상도에 따라 서로 다른 크기(모양)의 이미지를 로딩할 수 있다.

    해상도         폴더 이름

    초고해상도     /app/res/drawable-[xhdpi, xxhdpi, xxxhdpi]
    고해상도       /app/res/drawable-hdpi
    중간 해상도    /app/res/drawable-mdpi
    저해상도       /app/res/drawable-idpi


실습을 위해 image.xml 파일을 만들어보자.


    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:orientation="vertical" android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageButton
            android:id="@+id/imageButton"
            android:layout_width="50dp"
            android:layout_height="50dp"
            android:layout_marginTop="40dp"
            android:layout_marginLeft="40dp"
            app:srcCompat="@drawable/aa"
            android:contentDescription="ok button"/>

        <ImageView
            android:id="@+id/imageView6"
            android:layout_width="50dp"
            android:layout_height="50dp"
            android:layout_marginTop="160dp"
            android:layout_marginLeft="160dp"
            android:background="@drawable/asdasd"
            android:contentDescription="person button" />
    </LinearLayout>


이미지 버튼은 일반 버튼과 다르게 눌린 상태와 눌리지 않은 상태 표시가 되지 않는다.
이문제를 해결하려면 후에 배울 셀렉터(Selector)를 만들어 사용해야 한다.


        텍스트 뷰와 에디트텍스트의 다른 기능들


    커서 관련 속성

에디트텍스트는 입력할 때 커서가 깜빡인다. 이 커서는 문자열의 마지막 지점으로 이동하도록 되어있다.
근데 사용자가 전체 내용을 수정하게 편의를 제공할 수도 있다.
예로 selectAllOnFocus 속성을 true 로 하면 포커스 받을 때 문자열 전체가 선택된다.
또는 커서를 안보이게 하고싶다면 cursorVisible 속성을 "false" 로 지정할 수 있다.

커서를 이용하여 문자얄을 선택, 복사 ,잘라내기 등의 기능을 만들때 사용하ㅡㄴ 메소드들이다.


    public int getSelectionStart()
    public int getSelectionEnd()
    public void setSelection(int start, int stop)
    public void setSelection(int index)
    public void selectAll()
    public void extendSelection(int index)


getSelectionStart() 는 선택 영역의 시작 위치를 알려준다. End 는 그 반대이다.
getSelection() 메소드는 선택 영역을 지정할 때 사용하고 extendSelection() 은 선택 영역을 확정하는데
사용한다. selectAll() 은 전체 문자열을 선택한다.


    자동 링크 관련 속성

autoLink 속성을 true 로 하면 웹 페이지 주소나 이메일 주소를 링크 색상으로 표시하고
링크를 누르면 해당 주소나 메일 편집기를 띄울 수 있다.


    줄 간격 조정 관련 속성

줄 간격은 텍스트간의 줄 간격을 조절할 수 있으며 lineSpacingMultiplier 와 lineSpacingExtra 로 설정할 수 있다.
lineSpacingMultiplier 는 줄 간격을 기본 줄 간격의 배수로 설정할 수 있고
lineSpacingExtra 는 여유 값으로 설정할 때 사용한다. 배수 설정은 기본 값이 1.0 이며 작은 값으로 지정하면 더 좁게 보인다.


    대소문자 표시 관련 속성

capitalize 속성은 글자, 단어, 문장 단위로 대소문자를 조절할 수 있다.
속성으로 'character, words, sentences' 등으로 대소문자를 표시할 수 있다.


    줄임 표시 관련 속성

텍스트뷰에 많은 문자 입력 시 뒷 부분을 자르고 줄임표(...) 로 표시할 수 있다.
ellipsize 속성을 이용하고 디폴트 값인 'none' 은 뒷부분을 자르고 'start, middle, end' 로
각각의 부분에 잘라 보여줄 수 있다. 한줄로 표시할 때는 maxLines 속성을 사용한다.


    힌트 표시 관련 속성

에디트텍스트에 어느 내용을 입력하라고 힌트를 주고싶을 때 hind 속성을 사용하면 된다.
hint 속성으로 나타난 글자 색상을 바꾸고 싶다면 textColorHint 를 지정한다.


    편집 가능 관련 속성

에디트텍스트에 문자열을 편집 못하도록 하고싶다면 editable 값을 false 로 바꾸면 된다.


    문자열 변경 처리 관련 속성

에디트텍스트에 입력된 문자열을 확인하거나 맞는 포맷인지 확인할 때 getText() 메소드를 사용한다.
이때 리턴되는 객체는 Editable 로 toString() 로 일반 문자열을 확인할 수 있다.


만약 문자열이 사용자 입력에 따라 바뀌게 하는 기능은 TextChangedListener 를 사용할 수 있다.


    public void addTextChangedListener(TextWatcher watcher)


addTextChangedListener() 메소드로 textWatcher 객체를 설정할 수 있다.
이 객체는 텍스트 변경 때마다 발생하는 이벤트를 처리한다.


    public void beforeTextChanged(CharSequence s, int start, int count, int after)
    public void afterTextChanged(Editable s)
    public void onTextChanged(CharSequence s, int start, int before, int count)


편집되기 전, 후 등으로 확인할 수 있으며 길이를 확인할 때는 setFilters() 메소드로 InputFilter 객체를 파라미터로
전달하고 이 객체의 LengthFilter() 메소드를 호출하면 길이 값을 설정할 수 있다.


            03-2 드로어블 만들기


        뷰의 배경 이미지

뷰의 background 에 배경색이나 이미지 파일을 설정할 수 있는데 이미지를 설정하면 그 이미지는 아무 변화가 없다.
버튼에 이용 시 누를 때와 안누를 때의 변화가 없으므로 이때 드로어블을 사용한다.

실습을 위해 sample_drawable.xml 을 만든 후에 중앙에 버튼을 배치하자.
그리고 버튼의 background 속성에 drawable 탭을 찾아서 이미지를 씌우자.

text 속성에 Button 글자를 삭제하면 이미지만 보이게 된다.


        드로어블

드로어블은 뷰 객체 위에 그래픽을 그릴 수 있다. 이는 흔히 원이나 선을 말한다.
이 작업은 자바 코드가 아닌 XML 로 그래픽을 그리면 좀 더 편하다.

드로어블에는 이미지 파일을 보여줄 때 사용하는 비트맵 드로어블, 상태별로 참조할 수 있는 상태 드로어블,
두 드로어블이 서로 바뀌는 전환 드로어블, 색상이나 그러데이션을 포함하는 셰이프 드로어블 등이 있다.
지정한 거리만큼 안쪽으로 들어오는 인셋 드로어블이나 다른 드로어블을 클리핑하는 클립 드로어블,
다른 드로어블의 크기를 바꾸는 스케일 드로어블도 있다.


    드로어블    설명

    비트맵     이미지 파일을 보여줌
    상태       상태별 다른 비트맵 그래픽을 참조
    전환       두 드로어블이 서로 전환
    셰이프     색상, 그라데이션을 포함한 도형 모양 정의
    인셋       지정된 거리만큼 다른 드로어블을 들어서 보여줌
    클립       레벨 값을 기준으로 다른 드로어블을 클리핑
    스케일     레벨 값을 기준으로 다른 드로어블의 크기를 변경


        상태 드로어블 만들기

왼쪽 프로젝트 창에 drawable 폴더를 오른쪽 마우스 클릭하여 New -> Drawable resource files 를 선택한다.
finger_drawable.xml 파일을 만든다. 이 파일엔 <selector> 태그가 있는데
<item> 태그를 안에 넣어 drawable 속성에 이미지나 다른 그래픽을 설정하여 보여줄 수 있다.
state_ 로 시작하는 속성은 상태를 나타내는 간단한 예로 state_pressed 속성은 눌린상태,
state_focused 는 포커스 받은 상태를 의미한다. 이제 생성한 파일의 코드를 다음과 같이 수정한다.


    <?xml version="1.0" encoding="utf-8"?>
    <selector xmlns:android="http://schemas.android.com/apk/res/android">
        <item android:state_pressed="true"
            android:drawable="@drawable/aa" />

        <item android:drawable="@drawable/asdasd" />
    </selector>


상태 속성을 지정하지 않은 <item> 태그는 asdasd, 다른 <item> 태그는 aa 로 지정했는데
이렇게하면 누를 때는 aa, 누르지 않으면 asdasd 이미지를 보이게 한다.

이렇게 만든 XML 파일은 background 속성으로 지정할 수 있다.
sample_drawable.xml 파일에서 버튼의 background 속성 값을 @drawable/finger_drawable 로 변경한다.

이제 앱을 실행하여 버튼을 눌러보자.


        셰이프 드로어블 만들기

이번엔 셰이프 드로어블 실습을 위해 rect_drawable.xml 을 만든다. 그리고 코드는 다음과 같다.


    <?xml version="1.0" encoding="utf-8"?>
    <shape xmlns:android="http://schemas.android.com/apk/res/android"
        android:shape="rectangle">

        <size android:width="200dp" android:height="120dp"/>
        <stroke android:width="1dp" android:color="#0000ff" />
        <solid android:color="#aaddff" />
        <padding android:bottom="1dp" />
    </shape>


최상위 태그는 <select> 에서 <shape> 로 바뀌었으며 shape 란 속성을 추가하여 속성 값으로 rectangle 을 입력했다.
이렇게 사각형을 그릴 수 있으며 shape 속성에 oval 을 입력하면 타원을 그릴 수 있다.
<shape> 속성에 <size> 태그는 도형의 크기를 지정하는 태그로 여기서 가로 200dp, 세로 120dp 를 지정.
<stroke> 태그는 테두리 선을 지정하며 굵기, 색을 지정할 수 있고
<solid> 태그는 도형 안쪽을 채울 때 사용한다. <padding> 은 태두리 안쪽 공간을 띄우고 싶을 때 사용한다.

이제 rect_drawable 파일로 도형을 화면에 표시해보자.
새 버튼을 가운데 버튼 아래에 배치한다. 이때 배경을 @drawable/rect_drawable 로 지정한다.

이번엔 앱의 배경색을 바꿔보자. 그라데이션 호과를 주고 싶을 때는 <gradient> 태그를 사용한다.
drawable 폴더에 back_drawable.xml 파일을 새로 만든다.


    <?xml version="1.0" encoding="utf-8"?>
    <shape xmlns:android="http://schemas.android.com/apk/res/android">

        <gradient
            android:startColor="#7288DB"
            android:centerColor="#3250B4"
            android:endColor="#254095"
            android:angle="90"
            android:centerY="0.5" />

        <corners android:radius="2dp" />
    </shape>


<shape> 태그에 <gradient> 태그를 넣어 그러데이션을 만들 수 있다.
startColor 에 시작, centerColor 에 가운데, endColor 에 끝 부분의 색을 지정할 수 있다.

최상위 컨테이너 ConstraintLayout 을 선택하여 배경 속성을 @drawable/back_drawable 로 설정한다.

이번엔 반투명 배경을 만들고 테두리만 있는 버튼을 만들어보자.
<layer-list> 태그에 여러 그래픽을 하나의 XML 파일처럼 넣을 수도 있다.
하나의 그래픽으로 정의할 지 여러 그래픽으로 정의할 지는 선택의 문제이다. 하지만 여러 그래픽을 나누어 중첩시키면
더 예쁜 배경을 만들 수 있다.

drawable 폴더에 border_drawable.xml 이라는 파일을 만들자.


    <?xml version="1.0" encoding="utf-8"?>
    <layer-list xmlns:android="http://schemas.android.com/apk/res/android">

        <item>
            <shape android:shape="rectangle">
                <stroke android:width="1dp" android:color="#BE55DA" />
                <solid android:color="#00000000" />
                <size android:width="200dp" android:height="100dp" />
            </shape>
        </item>

        <item android:top="1dp" android:bottom="1dp"
            android:right="1dp" android:left="1dp">
            <shape android:shape="rectangle">
                <stroke android:width="1dp" android:color="#FF55DA" />
                <solid android:color="#00000000" />
            </shape>
        </item>
    </layer-list>


<layer-list> 태그에 두 <item> 태그가 있는데
첫 번째 <item> 태그는 <shape> 태그를 포함하고 사각형을 그렸다.
두 번째 <item> 태그는 네 방향을 지정하여 테두리 선으로 바깥으로 띄울 공간을 지정했다.
마지막으로 <solid> 태그로 안쪽을 투명하게 만들었다.

이제 sample_drawable 파일에서 중앙 버튼 위에 새 버튼을 추가하고 배경값을 @drawable/border_drawable 로 지정한다.


            03-3 이벤트 처리 이해


        이벤트 처리 방식

안드로이드는 화면 터치 시 터치 이벤트가 발생한다. 이 밖엔 주요 이벤트는 실제 버튼이나 소프트 키패드를 누르면 발생하는
키 이벤트도 있다.

터치에도 손가락 누를 때, 누른 상태로 움직일 때, 누른 상태로 땔 때 등 복잡할 수 있으며 이 처리를 쉽게 할 수 있도록
클릭 이벤트를 별도로 제공한다.

예로 onClick 속성을 버튼에 부여하면 메소드 이름만 넣으면 된다.
이렇게 버튼의 클릭 이벤트를 전달하여 쉽게 전달할 수 있다.
XML 이 아닌 자바 코드에서는 버튼의 setOnClickListener() 메소드로 리스너 설정을 할 수 있다.

이런 화면에 발생하는 이벤트를 버튼이나 위젯에 전달 후 처리하는 과정을 버튼에 위임한다고 '위임 모델' 이라 부른다.
각 이벤트 패턴은 각각의 뷰마다 하나의 이벤트 처리 루틴을 할당한다. 이러면 코드가 복잡하지 않고
이벤트를 위젯마다 개별적으로 처리하여 객체 지향 코드를 만들 수 있다.
위임 모델은 리스너 인터페이스를 등록할 수 있도록한다. onClickListener 는 이벤트 발생 시 즉시 동작하도록 하는
리스너 중 하나이다. 다음은 onClickListener 의 방식이다.


                                    OnClickListener 인터페이스
                                            ^
                                            │ 구현
                                            │
    Button 객체   <--- 설정 --- public void onClick(View v) {...}


이 패턴으로 다른 이벤트도 리스너 객체를 만들어 쉽게 처리할 수 있다.
다음은 대표적인 이벤트 처리 메소드이다. 이벤트 전달 후 이 메소드들이 자동 호출되어 이 메소드의 파라미터로
전달되는 이벤트 객체를 이용하여 필요한 작업을 수행할 수 있따.


    boolean onTouchEvent(MotionEvent event)
    boolean onKeyDown(int keyCode, KeyEvent event)
    boolean onKeyUp(int keyCode, KeyEvent event)


사용자가 화면 터치나 키패드 입력 시 이벤트가 발생하고 파라미터로 정보가 전달된다.
터치 시엔 MotionEvent, 키 입력 시엔 KeyEvent 가 전달된다.

이 메소드들은 재정의를 할 수 있으며 Button 클래스를 상속하여 MyButton 같은 새 클래스로 메소드를 재정의할 수 있다.
만약 새 뷰를 정의하지 않고 기존 뷰 객체에 이벤트를 처리하려면 리스너를 설정하는 메소드를 호출해야 한다.
다음은 기존 뷰 그대로 사용하며 해당 객체의 설정을 사용하는 메소드를 정의한 것이다. 모두 리스너 인터페이스를 구현하게 만들었다.


    View.OnTouchListener : boolean onTouch (View v, MotionEvent event)
    View.OnKeyListener : boolean onKey (View v, int keyCode, KeyEvent event)
    View.OnClickListener : void onClick(View v)
    View.OnFocusChangeListener : void onFocusChange(View v, boolean hasFocus)


OnClickListener 의 경우에는 버튼과 같은 객체에 자주 사용되지만 OnTouchListener 버튼 뿐 아닌 일반 뷰 객체에도 사용할 수 있다.
상호작용이 필요할 때 많이 사용되고 OnTouchListener 의 onTouch() 메소드는 터치 시에 발생되는 이벤트를 받아 처리할 수 있으며
OnKeyListener 의 onKey() 메소드는 키 입력 시 발생되는 이벤트를 처리한다.
뷰에 포커스가 주어지거나 없어질 경우 발생하는 FocusChange 이벤트는 OnFocusChangeListener 를 사용해 처리한다.


    속성

    터치 이벤트      화면을 손가락으로 누르면 발생
    키 이벤트        키패트나 하드웨어 버튼 누르면 발생
    제스처 이벤트    터치 이벤트 중 스크롤과 같은 일정 패턴으로 구분되는 이벤트
    포커스           뷰마다 순서대로 주어지는 포커스
    화면 방향 변경   화면 방향이 가로 세로로 바뀜에 따라 발생하는 이벤트


손가락으로 좌우 스크롤할 때와 같은 패턴을 포커스라고 한다.
일반적인 터치 이벤트보다 더 간단히 처리할 수 있으며 손으로 눌러 움직이는 스크롤도 하나의 이벤트로 만들어져
복잡한 이벤트를 더 쉽게 처리할 수 있다. 다음은 제스처 이벤트를 통해 처리할 수 있는 이벤트이다.


    메소드

    onDown()                    화면 누를 때
    onShowPress()               눌렀다 땔 때
    onSingleTabUp()             한 손가락으로 눌렀다 땔 때
    onSingleTabConfirmed()      한 손가락으로 눌러질 때
    onDoubleTap()               두 손가락으로 누를 때
    onDoubleTapEvent()          두 손가락으로 누른 상태로 때거나 이동하는 등 세부적인 액션
    onScroll()                  화면 누른 채 일정한 속도와 방향으로 움직였다 땔 때
    onFling()                   화면 누른채 가속도를 붙여 움직였다 땔 때
    onLongPress()               손가락으로 오래 누르는 경우


제스처 이벤트로 복잡한 이벤트들을 쉽게 처리할 수 있다.


        터치 이벤트 처리

layout 폴더에 sample_touch.xml 파일을 만들자.
최상위 레이아웃을 LinearLayout 으로 지정하고 ScrollView 하나와 View 두 개를 layout_weight 을 1로 지정하여 추가한다.
3 분할한 스크롤뷰의 배경색을 지정하여 보이게 해준다. 그리고 각 스크롤뷰의 아이디에 view, view2, view3 으로 지정하고
ScrollView 에는 텍스트뷰를 하나 추가한다.
마지막으로 TouchCodeActivity.java 파일을 생성하여 다음 코드를 작성한다.


    public class TouchCodeActivity extends AppCompatActivity {
        TextView textView;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_touch);

            textView = findViewById(R.id.textView20);

            View view = findViewById(R.id.view);
            view.setOnTouchListener(new View.OnTouchListener() {
                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    int action = event.getAction();

                    float curX = event.getX();
                    float curY = event.getY();

                    if(action == MotionEvent.ACTION_DOWN) {
                        println("손가락 눌림 : " + curX + ", " + curY);
                    } else if(action == MotionEvent.ACTION_MOVE) {
                        println("손가락 움직임 : " + curX + ", " + curY);
                    } else if(action == MotionEvent.ACTION_UP) {
                        println("손가락 땜 : " + curX + ", " + curY);
                    }

                    return true;
                }
            });
        }

        public void println(String data) {
            textView.append(data + "\n");
        }
    }


뷰 객체를 가져와 setOnTouchListener() 메소드로 리스너를 등록했다. 그리고 뷰가 터치되었을 때 리스너 객체의
onTouch() 메소드가 자동으로 호출된다.

onTouch() 메소드로 MotionEvent 객체가 파라미터로 전달된다. 이 객체는 액션 정보나 터치한 곳의 좌표 등의 정보가 있다.
getAction() 메소드로 터치했는지, 움직였는지 등의 값을 정수 자료형으로 반환하는데 MotionEvent 의 상수값으로
비교하며 상태를 알 수 있다.


    MotionEvent.ACTION_DOWN - 손가락 눌렀을 때
    MotionEvent.ACTION_MOVE - 손가락 눌린 상태로 움직일 때
    MotionEvent.ACTION_UP - 손가락 땠을 때


그리고 밑에 println 메소드를 정의하여 이벤트 결과를 텍스트뷰의 글자에 붙여 찍히는 것을 볼 수 있다.


        제스처 이벤트 처리하기

제스처 이벤트는 터치 이벤트 중 스크롤 등을 구별하여 알려주는 이벤트이다.
제스처 이벤트 처리 클래스는 GestureDetector 이며, 이 객체로 터치 이벤트를 전달하면 GestureDetector 객체에서
각 상황에 맞는 메소드를 호출한다. 화면에 추가한 두 번째 뷰를 터치했을 때 제스처 이벤트로 처리하도록
onCreate() 메소드 안에 다음 코드를 추가한다.


    GestureDetector detector;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        ...

        detector = new GestureDetector(this, new GestureDetector.OnGestureListener() {
            @Override
            public boolean onDown(MotionEvent e) {
                println("onDown() 호출됨");

                return true;
            }

            @Override
            public void onShowPress(MotionEvent e) {
                println("onShowPress() 호출됨");
            }

            @Override
            public boolean onSingleTapUp(MotionEvent e) {
                println("onSingTabUp() 호출됨");

                return true;
            }

            @Override
            public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
                println("onScroll() 호출됨 : " + distanceX + ", " + distanceY);

                return true;
            }

            @Override
            public void onLongPress(MotionEvent e) {
                println("onLongPress() 호출됨");
            }

            @Override
            public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                println("onFling() 호출됨 : " + velocityX + ", " + velocityY);

                return true;
            }
        });

        View view2 = findViewById(R.id.view2);
        view2.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                detector.onTouchEvent(event);
                return true;
            }
        });
    }


두 번째 뷰(view2)는 OnTouchListener 객체를 설정하고 있다.
그래서 두 번째 뷰 객체를 터치했을 때는 자동으로 onTouch() 메소드가 호출된다.
그리고 안에 GestureDetector 객체의 onTouchEvent() 메소드가 호출되면서 MotionEvent 가 전달된다.
이렇게 GestureDetector 객체가 터치 이벤트 처리 후 GestureDetector 객체에 정의된 메소드를 호출한다.
대표적으로 드래그 처리인 스크롤, 빠른 속도의 드래그 처리인 플링, 오래 누르면 호출되는 onLongPress() 등을
쉽게 처리할 수 있다.


        키 이벤트 처리하기

키 입력은 onKeyDown() 메소드를 재정의하여 처리할 수 있다. onKeyDown() 메소드로 전달되는 파라미터는
두 개로, KeyCode 는 어떤 키가 입력됐는지 구분하고 keyEvent 는 입력 이벤트의 정보를 알 수 있다.

키 입력은 키보드 뿐 아니라 [BACK] 버튼도 포함하여 처리할 수 있다.


    boolean onKeyDown(int keyCode, KeyEvent event)
    boolean onKey(View v, int keyCode, KeyEvent event)


두 번째 onKey() 메소드는 뷰의 OnKeyListener 인터페이스를 구현할 때 사용된다.
다음은 keyCode 정수 값으로 구분할 수 있는 대표적인 값을 설명하고 있다.


    키 코드

    KEYCODE_DPAD_[LEFT, RIGHT, UP, DOWN, CENTER]    방향 화살표와 중앙 버튼
    KEYCODE_CALL        통화 버튼
    KEYCODE_ENDCALL     통화 종료 버튼
    KEYCODE_BACK        뒤로가기 버튼
    KEYCODE_VOLUME_[UP, DOWN]       볼륨 증가 감소 버튼
    KEYCODE_0 ~9                    숫자 0 ~ 9 키
    KEYCODE_A ~ Z                   알파벳 A ~ Z 까지의 값


실제 앱 구성 시 키 입력의 대표적인 예는 카메라 미리보기를 하면서 사용하는 [카메라] 버튼과 시스템 [BACK]
버튼이 있다. 이 버튼들은 각각 KEYCODE_CAMERA 와 KEYCODE_BACK 으로 구분되는 코드 값을 가지고 있다.
시스템 [BACK] 버튼 이벤트는 onKeyDown() 메소드를 사용하면 간단히 처리할 수 있다.


TouchCodeActivity.java 파일에서 onKeyDown() 메소드를 오버라이드 작성한다.


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if(keyCode == KeyEvent.KEYCODE_BACK) {
            Toast.makeText(this, "시스템 [BACK] 버튼이 눌렸습니다.", Toast.LENGTH_SHORT).show();

            return true;
        }
        return false;
    }


onKeyDown() 메소드로 KEYCODE_BACK 이벤트를 확인하면 토스트 메시지가 표시되게 한다.
앱을 실행하고 시스템 [BACK] 버튼을 누르면 토스트 메시지를 볼 수 있다.


        단말 방향을 전환했을 때 이벤트 처리하기

앱을 만들 때 문제가 하나로 세로/가로 방향을 바꿨을 때 발생하는 방향 전환 문제가 있다.
단말 방향이 바뀔 때 가로 세로 화면의 비율에 따라 화면이 다시 보이게 된다.
가로 방향과 세로 방향 각각의 XML 레이아웃을 따로 만들어둘 필요가 있으며 방향 전환할 때마다
액티비티가 없어졌다 보이게하는 식으로 만들 수 있다.

방향이 바뀔 때 서로 다른 XML 레이아웃을 보여주는 방법에 대한 실습을 위해
새로운 폴더를 res 폴더에 만든다. New -> Android Resource Directory 를 선택하여
layout-land 를 만든다. 그 후에 layout-land 폴더에 sample_orientation.xml 을 만든다.

가로 방향일 때는 layout-land 폴더를 사용하게 된다. 즉, layout 폴더는 세로 방향을 사용한다.
layout 폴더에서는 텍스트뷰를 '세로 방향' layout-land 에서는 '가로 방향' 로 중앙에 배치한다.

단말 방향이 바뀔 때 액티비티를 메모리에서 지우고 다시만든다고 하니 확인해보자.
OrientationActivity.java 를 만들어 다음 코드를 작성한다. 재정의할 메소드는 onStart, onStop, onDestroy 로
이 메소드들이 추가되면 해당 메소드 호출 시 토스트 메시지가 나타나도록 하겠다.
이 메소드들은 자동으로 호출되며 '수명 주기' 또는 '생명 주기 메소드' 라 불린다. 자세한건 나중에 알아보자.


    public class OrientationActivity extends AppCompatActivity {
        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_orientation);
            showToast("onCreate 호출됨.");
        }

        @Override
        protected void onStart() {
            super.onStart();

            showToast("onStart 호출됨");
        }

        @Override
        protected void onStop() {
            super.onStop();

            showToast("onStop 호출됨");
        }

        @Override
        protected void onDestroy() {
            super.onDestroy();

            showToast("onDestroy 호출됨");
        }

        public void showToast(String data) {
            Toast.makeText(this, data, Toast.LENGTH_LONG).show();
        }
    }


각 재정의한 메소드마다 토스트 메시지가 나타나도록 하였다. 앱 실행 후 방향을 바꾸면
XML 레이아웃이 달라지며 토스트 메시지를 확인할 수 있다. 액티비티는 화면에 보이기 전에
메모리에 만들어져야 하는데 그 시점에 onCreate() 메소드가 호출된다. 그리고 화면에 보이기 전
onStart 메소드가 호출되어 화면이 보이다가 없어지면 onStop 이 호출되어 메모리에서 없어지는 경우
onDestroy 가 호출된다.

단말 방향을 바꾸려면 에뮬레이터의 오른쪽에 보이는 아이콘 중 [Rotate Left] 나 [Rotate Right] 아이콘을 사용한다.
문제가 있다면 단말 방향이 바뀔 때 액티비티가 메모리에 없어졌다가 새로 만들어진다는 점이다.
이 경우 액티비티 안에 선언한 변수 값이 모두 사라져서 저장했다 복원하는 방법이 있어야 한다.
이 문제를 해결하기 위해서 onSaveInstanceState 콜백 메소드를 제공한다.
이 메소드는 액티비티 종료 전의 상태를 저장한다. 그리고 이때 저장한 상태는 onCreate() 메소드가 호출될 때
전달되는 번들 객체로 복원할 수 있다.

상태 저장 후 복원하는 기능을 확인하기 위해 에디트텍스트와 버튼을 추가하자.
그리고 단말 방향을 돌릴 때 값을 저장했다가 복원해보자. 에디트텍스트의 'Name' 글자를 지우고 layout-land 폴더의
sample_orientation.xml 파일에도 동일하게 적용한다.

이제 OrientationActivity.java 파일을 열고 stanceState() 메소드를 재정의한다.


    public class OrientationActivity extends AppCompatActivity {
        String name;
        EditText editText;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_orientation);
            showToast("onCreate 호출됨.");

            editText = findViewById(R.id.editText);

            Button button = findViewById(R.id.button39);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    name = editText.getText().toString();
                    showToast("입력된 값을 변수에 저장했습니다 : " + name);
                }
            });

            if(savedInstanceState != null) {    // 이 화면이 초기화될 때 name 변수 값 복원
                name = savedInstanceState.getString("name");
                showToast("값을 복원했습니다 : " + name);
            }
        }

        ...

        @Override
        public void onSaveInstanceState(@NonNull Bundle outState) {
            super.onSaveInstanceState(outState);

            outState.putString("name", name);   // name 변수의 값 저장
        }
    }


name 변수를 선언하여 에디트텍스트의 글자를 할당하여 저장하게 했다.
setOnClickListener 메소드로 버튼의 리스너 객체를 설정할 때 사용되는 파라미터로 전달되는 객체는 new 연산자로 생성된다.
이렇게 OnClickListener 객체를 설정하면 버튼을 클릭했을 때 그 안의 onClick 메소드가 호출된다.

단말 방향을 바꾸면 액티비티 소멸 후 다시 만들어져 onSaveInstanceState() 메소드가 name 변수의 값으로 Bundle 객체에 넣는다.
이 데이터는 단말에 저장되고 onCreate() 메소드 호출될 때 파라미터로 전달되어 savedInstanceState 란 이름으로된
메소드로 데이터를 가져와 name 변수에 다시 할당된다.

이렇게 액티비티를 없애고 다시 생성되어 방향전환되는 방법 뿐만 아니라 액티비티는 바뀌지 않고 단순히 화면에 보이는 레이아웃만 바꾸고 싶다면
액티비티를 굳이 없앨 필요가 없다. 유지할 수 있는 방법이 따로 있는데 내부 센서로 방향이 바뀌는 시점을 알아채고
바뀌는 이벤트를 앱에 전달받도록 하고 액티비티는 그대로 유지하는 방법을 사용할 수 있다.
이 방법은 먼저 매니페스트에 액티비티를 등록할 때 configChanges 속성을 설정해야 한다.

단말 방향 바뀔 때 액티비티 유지할 방법으로 sample_orientation2.xml 파일을 만든다.
텍스트뷰로 '단말 방향 바꿔보세요.' 로 변경하고 30sp 로 설정한다.

후에 AndroidManifest.xml 파일을 열어 <activity> 태그의 액티비티를 등록하는 태그에
configChanges 속성을 추가한다.


    <activity android:name=".OrientationActivity2"
        android:configChanges="orientation|screenSize|keyboardHidden">
        <intent-filter>
            <action android:name="android.intent.action.MAIN" />

            <category android:name="android.intent.category.LAUNCHER" />
        </intent-filter>
    </activity>


configChanges 속성은 액티비티 상태 변화를 알려주며 속성 값으로 "orientation|screenSize|keyboardHidden" 을 설정하면
단말 방향 바뀔 때 액티비티에 인식할 수 있고, configurationChanged() 메소드가 자동 호출된다.
keyboardHidden 값은 단말 방향 전환과는 관련 없지만 자주 사용되는 값 중 하나이다.
이 값을 함께 설정하면 액티비티 보일 때 키패트가 자동으로 나타나지 않게 하고 키패드가 보여야할 시점을 알려주기만 한다.
OrientationActivity2.java 파일을 열어 onConfigurationChanged() 메소드를 재정의한다.


    public class OrientationActivity2 extends AppCompatActivity {
        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.sample_orientation2);
        }

        @Override
        public void onConfigurationChanged(@NonNull Configuration newConfig) {
            super.onConfigurationChanged(newConfig);

            if(newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
                showToast("방향 : ORIENTATION_LANDSCAPE");
            } else if(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) {
                showToast("방향 : ORIENTATION_PORTRAIT");
            }
        }

        public void showToast(String data) {
            Toast.makeText(this, data, Toast.LENGTH_LONG).show();
        }
    }


onConfigurationChanged() 메소드 호출될 때 전달되는 Configuration 객체엔 orientation 속성이 들어 있어
단말 방향이 가로로 바뀌었는지 세로로 바뀌었는지 알 수 있다.

방향을 세로 또는 가로로 고정하고 싶다면 매니페스트 파일에 screenOrientation 속성 값을 지정하면 된다.


    <activity android:name=".OrientationActivity2"
        android:configChanges="orientation|screenSize|keyboardHidden"
        android:screenOrientation="landscape">
    </activity>


            03-4 토스트, 스낵바 그리고 대화상자 사용

디버깅 메시지 확인을 위해 Log 클래스를 사용하여 로그 출력을 할 수 있는데 이 로그는 Logcat 창에서 확인할 수 있다.
화면에 뿌려지는 메시지는 토스트 메시지를 사용할 수 있다.

토스트는 간단한 메시지를 보여주었다 사라지는 뷰로 앱 위에 떠있는 뷰라할 수 있다.
포커스를 받지 않으므로 대화상자보다 더 쉽고 간단히 사용할 수 있어 디버깅 목적으로도 사용할 수 있다.


    Toast.makeText(Context context, String message, int duration).show();


Context 객체는 Context 클래스를 상속한 액티비티를 사용할 수 있고 액티비티를 참조할 수 없을 때는
getApplicationContext() 메소드로 호출하면 Context 객체가 반환된다.
메시지와 디스플레이 시간을 파라미터로 전달하고 show() 메소드를 호출하여 시간을 지정할 수 있고
위치나 모양도 다음 두 메소드로 위치와 여백을 지정할 수 있다.


    public void setGravity(int gravity, int xOffset, int yOffset)
    public void setMargin(float horizontalMargin, float verticalMargin)


setGravity() 메소드는 뷰의 위치를 지정할 수 있고 첫 파라미터는 gravity 값에 Gravity.CENTER 와 같이 정렬 위치를 지정한다.
setMargin() 에는 외부 여백을 지정할 수 있다.


        토스트 위치 바꿔 보여주기

토스트를 임의의 위치 좌표에 지정하여 보여주도록 하자. toast_gravity.xml 파일을 만들어
다음 XML 레이아웃을 작성한다.


    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <EditText
                android:id="@+id/editText"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:textSize="20dp"
                android:hint="X 위치"
                android:inputType="numberSigned" />

            <EditText
                android:id="@+id/editText2"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:textSize="20dp"
                android:hint="Y 위치"
                android:inputType="numberSigned" />

            <Button
                android:id="@+id/button40"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="띄우기"
                android:textSize="20sp"
                android:onClick="onButton1Clicked" />
        </LinearLayout>
    </LinearLayout>


이 레이아웃은 inputType 을 numberSigned 로 지정하여 숫자만 입력할 수 있는 에디트텍스트 두 개와 버튼을
추가하였다. 이제 ToastGravity.java 파일을 만들어 다음과 같이 작성하자.


    public class ToastGravity extends AppCompatActivity {
        EditText editText;
        EditText editText2;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.toast_gravity);

            editText = findViewById(R.id.editText);
            editText2 = findViewById(R.id.editText2);
        }

        public void onButton1Clicked(View v) {
            try {
                Toast toastView = Toast.makeText(this, "위치가 바뀐 토스트 메시지입니다.", Toast.LENGTH_LONG);

                int xOffset = Integer.parseInt(editText.getText().toString());
                int yOffset = Integer.parseInt(editText2.getText().toString());

                toastView.setGravity(Gravity.TOP|Gravity.TOP, xOffset, yOffset);
                toastView.show();
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
        }
    }


두 에디트텍스트로 입력된 두 정수로 토스트 위치 값을 지정하였다.
setGravity() 메소드로 위치를 지정하고 show() 메소드러 호출하여 토스트를 보이게했다.
xOffset 과 yOffset 은 dpi 에 따라 달라질 수 있으니 픽셀 값 설정이 좋다.
만약 첫 ㅂ파라미터 값을 Gravity.CENTER 로 하면 위치 설정의 기준을 가운데로 하고 두, 세 번째 파라미터 값으로
조정하게 된다.


        토스트 모양 바꿔 보여주기

토스트는 위치 뿐 아니라 모양도 바꿀 수 있다. toast_gravity 파일에 버튼을 더 추가하고
'모양 바꿔 띄우기' 라고 텍스트를 지정한다. 그 버튼이 눌렸을 때 onButton2Clicked() 메소드를 호출되게 한다.


    public void onButton2Clicked(View v) {
        LayoutInflater inflater = getLayoutInflater();  // 레이아웃 인플레이터 객체 참조

        View layout = inflater.inflate(
                R.layout.toastborder,
                (ViewGroup) findViewById(R.id.toast_layout_root));

        TextView text = layout.findViewById(R.id.text3);

        Toast toast = new Toast(this);
        text.setText("모양 바꾼 토스트");
        toast.setGravity(Gravity.CENTER, 0, -100);
        toast.setDuration(Toast.LENGTH_SHORT);
        toast.setView(layout);
        toast.show();
    }


버튼을 눌렀을 때 처리되는 부분에 LayoutInflater 객체로 XML 로 정의된 레이아웃(toastborder)을 객체화 하였다.
XML 레이아웃 파일은 setContentView() 메소드로 액티비티에 설정되지만 LayoutInflater 객체로 직접 메모리에 객체화할 수 있다.
이는 나중에 자세히 살펴보자.

대상 레이아웃은 R.layout.toastborder 로 되어 있다. layout 폴더에 toastborder.xml 의 레이아웃 파일을 만들자.


    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/toast_layout_root"
        android:padding="10dp">

        <TextView
            android:id="@+id/text3"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:padding="20dp"
            android:textSize="32dp"
            android:background="@drawable/toast" />
    </LinearLayout>


이 XML 파일은 토스트 형태를 정의한 것으로 토스트 메시지를 보이게할 것이다.
id 가 text3 인데 토스트 뷰를 위한 레이아웃은 항상 이 형태로 작성되어야 한다.
배경을 그릴 객체는 toast 이므로 drawable 폴더에 toast.xml 파일을 만든다.
이는 세이프 드로어블로 작성한다.


    <?xml version="1.0" encoding="utf-8"?>
    <shape xmlns:android="http://schemas.android.com/apk/res/android"
        android:shape="rectangle">

        <stroke
            android:width="4dp"
            android:color="#ffffff00" />
        <solid
            android:color="#ff883300" />
        <padding
            android:left="20dp"
            android:top="20dp"
            android:right="20dp"
            android:bottom="20dp" />
        <corners
            android:radius="15dp" />
    </shape>


이렇게 정의한 XML 정보는 자바 setView() 메소드로 토스트 객체가 설정된다.
모양 바꿔 띄우기 버튼으로 확인해보자.


        스낵바 보여주기

간단한 메시지로 토스트 대신 스낵바도 이용할 수 있다. 이는 외부 라이브러리이기 때문에
스낵바가 있는 머티리얼 라이브러리를 프로젝트에 추가해야 한다.

머티리얼 라이브러리엔 AppBarLayout 등도 있는데 쉽게 추가할 수 있게 팔레트에 표시된다.
toast_gravity.xml 파일의 팔레트 창에 Containers 그룹을 선택하여 다운로드 버튼으로 설치해보자.

추가 후에 새로운 버튼을 하나 더 추가하고 '스낵바 띄우기' 글자로 수정한다.
그리고 ToastGravity 클래스에 onButton3Clicked() 메소드를 추가한다.


    public void onButton3Clicked(View v) {
        Snackbar.make(v, "스낵바입니다.", Snackbar.LENGTH_LONG).show();
    }


앱을 실행하고 [스낵바 띄우기] 버튼을 누르면 아래에 스낵바 메시지가 나타났다 사라진다.


        알림 대화상자 보여주기

토스트와 함께 사용될 알림 대화상자는 사용자에게 확인 받거나 선택하게 할 때 사용한다.
보통 알림 대화상자는 사용자 입력 받기 보단 일방적으로 메시지를 전달하는 역할로 '예', '아니오' 같은 전형적인
응답을 처리한다.

실습을 위한 alert_dialog.xml 파일을 새로 만들어 버튼와 텍스트 뷰를 하나씩 추가하고
텍스트뷰의 글자는 '버튼을 누르면 대화상자가 뜹니다', 버튼은 '띄우기' 로 수정한다.
AlertDialog.java 파일을 만들고 다음 코드를 작성한다.


    public class AlertDialogActivity extends AppCompatActivity {
        TextView textView;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.alert_dialog);

            textView = findViewById(R.id.textView24);

            Button button = findViewById(R.id.button43);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    showMessage();
                }
            });
        }

        private void showMessage() {
            AlertDialog.Builder builder = new AlertDialog.Builder(this);    // 대화상자 빌더 객체 생성
            builder.setTitle("안내");
            builder.setMessage("종료하시겠습니까?");
            builder.setIcon(android.R.drawable.ic_dialog_alert);

            builder.setPositiveButton("예", new DialogInterface.OnClickListener() {  // 예 버튼 추가
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    String message = "예 버튼이 눌렸습니다.";
                    textView.setText(message);
                }
            });

            builder.setNeutralButton("취소", new DialogInterface.OnClickListener() {  // 취소 버튼 추가
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    String message = "취소 버튼이 눌렸습니다.";
                    textView.setText(message);
                }
            });

            builder.setNegativeButton("아니오", new DialogInterface.OnClickListener() {    // 아니오 버튼 추가
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    String message = "아니오 버튼이 눌렸습니다.";
                    textView.setText(message);
                }
            });

            AlertDialog dialog = builder.create();  // 객체 생성 후 보이기
            dialog.show();
        }
    }

AlertDialog 는 기본 API 포함된 것과 appcompat 패키지에 포함된 것도 있다.

AlertDialog 클래스는 알림 대화상자를 보여주는 가장 단순한 방법을 제공한다.
setTitle() 메소드로 설정한 내용은 setMessage() 메소드로 설정한다. 아이콘은 setIcon() 으로 설정할 수 있다.
'예', '아니오' 버튼은 각각 setPositiveButton() 과 setNegativeButton() 메소드를 사용한다.
이 메소드는 OnClickListener 를 설정하여 버튼 눌릴 때 어떤 버튼이 눌렸는지 표시한다.


            03-5 프로그레스바 사용하기


        프로그레스바

어떤 일의 진행 상태를 중간 중간 보여줄 수 있는 가장 좋은 방법은 하나가 프로그레스바이다.
작업 진행 정도를 표시하거나 작업이 진행 중임을 사용자에게 알려준다. 대표 두 가지 형태의 프로그레스바를 표로 정리하였다.


    속성              설명

    막대 모양       작업 진행도를 막대 모양으로 표시
                   style 속성 값을 '?android:attr/progressBarStyleHorizontal' 로 설정

    원 모양        작업 진행도를 알려줌
                   원 모양으로 된 프로그레스바가 반복적으로 표시


XML 레이아웃에 프로그래스바를 추가할 때는 <ProgressBar> 태그가 사용되는데, 갖는 값의 최대 범위는
max 속성으로 설정하고 현재 값은 progress 속성으로 설정한다.
예로 max 값이 '100' 인데 진행률이 50% 라면 progress 값은 '50' 으로 설정하면 된다.
자바 코드로 값을 바꾸는데 대표 메소드는 다음과 같다.


    void setProgress(int progress)
    void incrementProgressBy(int diff)


setProgress() 메소드는 정수값을 받아 프로그레스바의 현재 값을 설정한다.
incrementProgressBy() 메소드는 현재 설정된 값을 더하거나 뺄 때 사용한다.
프로그레스바는 항상 보일 필요가 없으며 화면의 차지하는 공간을 줄일 수 있도록 타이틀바에
프로그레스바를 표시할 수도 있다. 이는 다음 메소드를 사용해야 한다.


    requestWindowFeature(Window.FEATURE_PROGRESS);


타이틀 부분에 표시되는 프로그레스바는 범위를 따로 지정할 수 없으니 디폴트 값으로 0 부터 10000 사이 값을 가질 수 있다.
따라서 진행률이 50% 면 5000 으로 설정해야 한다. 타이틀바에 프로그레스바를 보여주는 방식은 화면 공간을
절약하는 직관적인 방식이지만 타이틀 부분을 보이지 않게 설정하는 경우가 많으니 사용할 수 없는 경우도 생기는 것을 주의하자.

실습을 위해 progress.xml 파일을 만들고 프로그레스바를 추가하고 max 값은 100 으로 설정한다.
그리고 버튼 '보여주기' 와 '닫기' 를 추가한다.

첫 번째 버튼은 프로그레스바를 대화상자로 보여주고 두 번째 버튼은 그 대화상자를 없애주는 역할이다.
그럼 ProgressActivity.java 파일을 만들고 코드를 다음과 같이 작성한다.


    public class ProgressActivity extends AppCompatActivity {
        ProgressDialog dialog;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.progress);

            ProgressBar progressBar = findViewById(R.id.progressBar);
            progressBar.setIndeterminate(false);
            progressBar.setProgress(80);

            Button button = findViewById(R.id.button44);
            button.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    dialog = new ProgressDialog(ProgressActivity.this); // 프로그레스 대화상자 객체
                    dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                    dialog.setMessage("데이터를 확인하는 중입니다.");

                    dialog.show();
                }
            });

            Button button2 = findViewById(R.id.button45);
            button2.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if(dialog != null)      // 프로그레스 대화상자 없애기기
                        dialog.dismiss();
                }
            });
        }
    }


버튼 클릭 시 프로그레스바 대화상자가 표시되는데 멈추지 않는 프로그레스바를 보여준다.
이를 보여주려면 그 스타일을 ProgressDialog.STYLE_SPINNER 로 설정 한다.
그리고 ProgressDialog 객체를 생성할 때는 Context 객체가 파라미터로 전달되야 하는데
해당 액티비티인 ProgressActivity 객체를 전달했다.